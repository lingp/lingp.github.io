<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用uniapp遇到的问题</title>
      <link href="/2023/06/06/uniapp-problem/"/>
      <url>/2023/06/06/uniapp-problem/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="使用Uniapp遇到的问题和坑，版本：vue3，HbuilderX-3-8-4-20230531"><a href="#使用Uniapp遇到的问题和坑，版本：vue3，HbuilderX-3-8-4-20230531" class="headerlink" title="使用Uniapp遇到的问题和坑，版本：vue3，HbuilderX-3.8.4.20230531"></a>使用Uniapp遇到的问题和坑，版本：vue3，HbuilderX-3.8.4.20230531</h1><h2 id="1-字体文件引入不成功？"><a href="#1-字体文件引入不成功？" class="headerlink" title="1.字体文件引入不成功？"></a>1.字体文件引入不成功？</h2><p>参考链接：<a href="https://uniapp.dcloud.net.cn/tutorial/project.html">https://uniapp.dcloud.net.cn/tutorial/project.html</a><br>static:存放应用引用的本地静态资源（如图片、视频、图标字体文件等）的目录，<strong>注意：静态资源只能存放于此</strong></p><h2 id="2-使用nvue时，slot引入图标，在app不生效？"><a href="#2-使用nvue时，slot引入图标，在app不生效？" class="headerlink" title="2.使用nvue时，slot引入图标，在app不生效？"></a>2.使用nvue时，slot引入图标，在app不生效？</h2><p>在非App下slot正常使用，这种用法在app上不生效</p><pre><code>父：&lt;text class=&quot;iconfont&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/text&gt;子：&lt;IconButton&gt;&amp;#xe848;&lt;/IconButton&gt;</code></pre><p>在app上生效的方式，在子组件定义一个icon, 父组件传值进来’\ue848’，单引号不能缺失，注意如下</p><pre><code>父：&lt;text class=&quot;iconfont&quot;&gt;&#123;&#123;icon&#125;&#125;&lt;/text&gt;子：&lt;IconButton :icon=&quot;&#39;\ue848&#39;&quot;&gt;&lt;/IconButton&gt;</code></pre><p>完整代码</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;view class=&quot;flex flex-row align-center justify-center mr-2&quot;&gt;    &lt;IconButton :icon=&quot;&#39;\ue848&#39;&quot;&gt;&amp;#xe848;&lt;/IconButton&gt;    &lt;IconButton :icon=&quot;&#39;\ue84f&#39;&quot;&gt;&amp;#xe84f;&lt;/IconButton&gt;&lt;/view&gt;</code></pre><pre><code class="html">&lt;!-- 子组件 --&gt;&lt;template&gt;    &lt;view class=&quot;flex align-center justify-center&quot; hover-class=&quot;bg-hover-light&quot; style=&quot;height: 80rpx; width: 80rpx;&quot;&gt;        &lt;!-- #ifdef APP-PLUS-NVUE --&gt;            &lt;text class=&quot;iconfont&quot; style=&quot;font-size: 50rpx;color: #000000;&quot;&gt;&#123;&#123;icon&#125;&#125;&lt;/text&gt;        &lt;!-- #endif --&gt;                &lt;!-- #ifndef APP-PLUS-NVUE --&gt;            &lt;text class=&quot;iconfont&quot; style=&quot;font-size: 50rpx;color: #000000;&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/text&gt;        &lt;!-- #endif --&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps(&#123;  icon: String&#125;)&lt;/script&gt;</code></pre><h2 id="2-使用nvue时，slot在微信小程序不渲染的问题？"><a href="#2-使用nvue时，slot在微信小程序不渲染的问题？" class="headerlink" title="2.使用nvue时，slot在微信小程序不渲染的问题？"></a>2.使用nvue时，slot在微信小程序不渲染的问题？</h2><p>子组件定义</p><pre><code class="html">&lt;text v-if=&quot;isShowTitle&quot;&gt;&lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;&lt;/text&gt;</code></pre><p>有问题的代码</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;navBarVue :isShowTitle=&quot;true&quot;&gt;    &lt;!-- 这样微信小程序不展示 --&gt;    &lt;template v-slot:title&gt;WeChat&lt;/template&gt; &lt;/navBarVue&gt;</code></pre><p>解决方式</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;navBarVue :isShowTitle=&quot;true&quot;&gt;    &lt;!-- 这里多加一个&lt;text&gt;&lt;/text&gt;不然小程序不渲染，真是奇怪 --&gt;    &lt;template v-slot:title&gt;&lt;text&gt;WeChat&lt;/text&gt;&lt;/template&gt; &lt;/navBarVue&gt;</code></pre><h2 id="3-微信小程序端不支持计算属性绑定对象给-class、style"><a href="#3-微信小程序端不支持计算属性绑定对象给-class、style" class="headerlink" title="3.微信小程序端不支持计算属性绑定对象给 class、style"></a>3.微信小程序端不支持计算属性绑定对象给 class、style</h2><p>这样是不行的，渲染后的元素节点显示 object。</p><pre><code class="vue">&lt;template&gt;  &lt;view class=&quot;dictionary-picker&quot;&gt;    &lt;view :class=&quot;boxStyle&quot;&gt;&lt;/view&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  computed: &#123;    boxStyle() &#123;      return &#123;        active: this.activeTab ? true : false,      &#125;;    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><p>解决方法：不通过计算属性，直接在属性上绑定逻辑。</p><pre><code class="vue">&lt;template&gt;  &lt;view class=&quot;dictionary-picker&quot;&gt;    &lt;view :class=&quot;[activeTab ? &#39;active&#39; : &#39;&#39;]&quot;&gt;&lt;/view&gt;  &lt;/view&gt;&lt;/template&gt;</code></pre><h2 id="4-opacity-0-在uniapp中，点击事件不生效，但是background-color-rgba-0-0-0-0-则可以。"><a href="#4-opacity-0-在uniapp中，点击事件不生效，但是background-color-rgba-0-0-0-0-则可以。" class="headerlink" title="4. opacity: 0; 在uniapp中，点击事件不生效，但是background-color: rgba(0, 0, 0, 0)则可以。"></a>4. opacity: 0; 在uniapp中，点击事件不生效，但是background-color: rgba(0, 0, 0, 0)则可以。</h2><p>发现这个问题的起因：为了将蒙版透明，但是需要点击关闭的事件生效，发现opacity: 0;不可以，但是background-color: rgba(0, 0, 0, 0)可以</p><pre><code class="html">&lt;!-- 正常 opacity: 0; 在网页中是生效的，但是在uniapp不生效，如下 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;test&quot; style=&quot;height: 100vh; width: 100vw; background-color: red;    opacity: 0;    &quot;&gt;        1    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    window.onload = function() &#123;       let obj = document.getElementById(&quot;test&quot;);       obj.onclick = function() &#123;         alert(&quot;hello world;&quot;)       &#125;    &#125;&lt;/script&gt;&lt;/html&gt;&lt;!-- uniapp 生效代码 --&gt;&lt;template&gt;    &lt;!-- 弹出层 --&gt;    &lt;view style=&quot;z-index: 100;overflow: hidden;&quot; v-if=&quot;status&quot;&gt;        &lt;!-- 蒙版 --&gt;        &lt;view v-if=&quot;mask&quot; class=&quot;mask-main&quot;  :class=&quot;&#123;transparent: isTransparent&#125;&quot;  @click=&quot;hide&quot;&gt;&lt;/view&gt;        &lt;!-- 弹出框内容 --&gt;        &lt;view style=&quot;position: fixed; z-index: 9999;&quot; :style=&quot;`top:$&#123;positionY&#125;px; left:$&#123;positionX&#125;px`&quot;&gt;            &lt;slot&gt;&lt;/slot&gt;        &lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps(&#123;    &quot;mask&quot;: &#123;        type: Boolean,        default: true    &#125;,    // 弹出层内容宽度    &quot;bodyWidth&quot;:&#123;        type:Number,        default:0    &#125;,    // 弹出层内容高度    &quot;bodyHeight&quot;:&#123;        type:Number,        default:0    &#125;,    // tabbar高度    &quot;tabbarHeight&quot;:&#123;        type:Number,        default:0    &#125;,  // 蒙版是否透明    &quot;isTransparent&quot;: &#123;        type: Boolean,        default: false    &#125;&#125;)const hide = () =&gt; &#123;    status.value = false&#125;&lt;/script&gt;&lt;style scoped&gt;    .mask-main &#123;        position: fixed;        left: 0;        bottom: 0;        right: 0;        top: 0;        background-color: rgba(0, 0, 0, 0.5);        z-index: 1;    &#125;    .transparent &#123;        background-color: rgba(0, 0, 0, 0) !important;    &#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题</title>
      <link href="/2023/06/03/java-basic-interview-questions/"/>
      <url>/2023/06/03/java-basic-interview-questions/</url>
      
        <content type="html"><![CDATA[<p><em><strong>目前只整理我自己觉得比较常问的题，补充ing</strong></em><br>[toc]</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="1-Java有哪些数据类型？"><a href="#1-Java有哪些数据类型？" class="headerlink" title="1.Java有哪些数据类型？"></a>1.Java有哪些数据类型？</h3><p>Java数据类型分为两种：基本数据类型和引用数据类型</p><img src="/2023/06/03/java-basic-interview-questions/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class=""><p>基本数据类型分为：</p><ol><li>数值型</li><li>整数类型（byte、short、int、long）</li><li>浮点类型（float、double）</li><li>字符型（char）</li><li>布尔型（boolean）</li></ol><p>Java 基本数据类型范围和默认值：</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>int</td><td>32</td><td>4</td><td>0</td></tr><tr><td>short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>char</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><p>引用数据类型：</p><ol><li>类（class）</li><li>接口（interface）</li><li>数组（[]）</li></ol><p><strong>注意：string不是基本的数据类型</strong></p><h3 id="2-switch-是否能作用在-byte-x2F-long-x2F-String-上？"><a href="#2-switch-是否能作用在-byte-x2F-long-x2F-String-上？" class="headerlink" title="2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？"></a>2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？</h3><p>Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。<br>从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。<br>从 Java 7 开始，expr 还可以是字符串(String)，但是<strong>长整型(long)在目前所有的版本中都是不可以的</strong>。<br><em>ps: 好冷门的题。。。</em></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="final-关键字有什么作用？"><a href="#final-关键字有什么作用？" class="headerlink" title="final 关键字有什么作用？"></a>final 关键字有什么作用？</h3><p>final，表示不可变的意思，可用于修饰类、属性和方法</p><ol><li>被final修饰的类<strong>不可以被继承</strong></li><li>被final修饰的方法<strong>不可以被重写</strong></li><li>被final修饰的变量不可变，被final修饰的变量必须被<strong>显式地指定初始值</strong>，还得注意的是，<strong>这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变</strong>。</li></ol><h3 id="x3D-x3D-和-equals-的区别？"><a href="#x3D-x3D-和-equals-的区别？" class="headerlink" title="&#x3D;&#x3D;和 equals 的区别？"></a>&#x3D;&#x3D;和 equals 的区别？</h3><p>&#x3D;&#x3D;：作用是判断两个对象的<strong>地址</strong>是否相等。即判断两个对象是不是同一个对象，<strong>基本数据类型比较的是值，引用类型比较的是内存地址</strong></p><p>equals：</p><ol><li>默认情况下，类没有覆盖equals()方法，则通过equals比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是内存地址</li><li>自定义的情况：类覆盖equals()方法，<strong>一般是比较两个对象的内容是否相同</strong>，自定义了一个相等的标准，也就是两个对象的值是否相等</li></ol><pre><code class="java">public class Person &#123;   private String name;   private String age;   @Override   public boolean equals(Object o) &#123;       if (this == o) return true;       if (!(o instanceof Person)) return false;       Person person = (Person) o;       return Objects.equals(age, person.age) &amp;&amp;               Objects.equals(name, person.name);   &#125;   @Override   public int hashCode() &#123;       return Objects.hash(age, name);   &#125;&#125;</code></pre><h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals?"></a>hashCode 与 equals?</h3><p><em><strong>面试常问：你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode ⽅法？</strong></em></p><ol><li><p>什么是hashCode?<br> 1.1 hashCode()的作用是获取哈希码，即散列码，实际上它返回一个<strong>int整数</strong>，定义在Object类中，是一个<strong>本地方法</strong>，这个方法常用来<strong>将对象的内存地址转为整数</strong>后返回</p><pre><code class="java">public native int hashCode();</code></pre><p> 1.2 哈希码主要在哈希表这类集合映射的时候用到，哈希表存储的是键值对(key-value)，它的特点是：能根据“键”快速的映射到对应的“值”。这其中就利⽤到了哈希码！  </p><p> 1.3 例如：HashMap 怎么把 key 映射到对应的 value 上呢？用的就是<strong>哈希取余法</strong>，也就是拿哈希码和存储元素的数组的长度取余，获取 key 对应的 value 所在的下标位置。</p></li><li><p>为什么重写 equals 时必须重写 hashCode ⽅法？(参考：<a href="https://juejin.cn/post/7024410950841139207">https://juejin.cn/post/7024410950841139207</a>)<br> 如果两个对象相等，则hashcode一定也是相同的。<br> 但反之，两个对象有相同的hashcode值，它们也不一定相等。(hash碰撞)</p><ul><li><p>每当重写equals时，通常都需要重写hashCode方法，以维护hashCode方法的一般约定，即相等的对象必须具有相等的哈希码。（注意：这里来源于Object.equals的注释）</p> <img src="/2023/06/03/java-basic-interview-questions/Object-equals.png" class=""></li><li><p>例：Java中的String类，这个类在Java集合中用到很多，例如我们平时使用的HashMap&#x2F;Set等等集合，都是经常性的使用String类型去当作key来进行使用的。String重写了equals和hashcode</p><ul><li><p>如果String没有重写equals，也就是继承了Object类的equals方法的话，则如果String类型为key的时候，<strong>相同的字符串，也可能会被当成两个不一样的key</strong>，从而难以辨别。</p></li><li><p>如果String重写了equals，没有重写hashCode。那么也会出现，同一个key出现在不同的位置，因为集合中常用哈希函数来计算key的位置，在没有重写hashCode的情况下，则<strong>同一个key会出现hashCode值不同而导致位置不同</strong>。</p></li></ul></li></ul></li></ol><h3 id="深拷贝和浅拷贝？"><a href="#深拷贝和浅拷贝？" class="headerlink" title="深拷贝和浅拷贝？"></a>深拷贝和浅拷贝？</h3><ul><li>浅拷贝：仅拷贝被拷贝对象的成员变量的值，也就是<strong>基本数据类型变量的值</strong>，和<strong>引用数据类型变量的地址值</strong>，而对于引用类型变量指向的堆中的对象不会拷贝</li><li>深拷贝：完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份</li></ul><p>深拷贝是安全的，浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象。</p><p>举例：现在有个Order对象，成员变量，有个基本数据类型order_no，还有一个引用数据类型products</p><img src="/2023/06/03/java-basic-interview-questions/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D.png" class=""><blockquote><p>浅拷贝如何实现呢？</p></blockquote><p> Object 类提供的 clone()方法可以非常简单地实现对象的浅拷贝。</p><blockquote><p>深拷贝如何实现呢？</p></blockquote><ol><li>重写克隆方法：重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归。</li><li>序列化：可以先将<strong>原对象序列化</strong>，再<strong>反序列化成拷贝对象</strong>。</li></ol><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String和StringBuilder、StringBuffer的区别"><a href="#String和StringBuilder、StringBuffer的区别" class="headerlink" title="String和StringBuilder、StringBuffer的区别"></a>String和StringBuilder、StringBuffer的区别</h3><ul><li>String: String的值被创建后就不能修改，<strong>任何对String对象的修改都会引发新的String对象的生成</strong></li><li>StringBuffer：跟String类似，但是<strong>值可以被修改</strong>，则不生成新的对象，使用synchronized来保证线程安全</li><li>StringBuilder：StringBuffer的<strong>非线程安全版</strong>，性能上更高一些</li></ul><h3 id="String-str1-x3D-new-String-“abc”-和String-str2-x3D-”abc”的区别"><a href="#String-str1-x3D-new-String-“abc”-和String-str2-x3D-”abc”的区别" class="headerlink" title="String str1&#x3D;new String(“abc”)和String str2&#x3D;”abc”的区别"></a>String str1&#x3D;new String(“abc”)和String str2&#x3D;”abc”的区别</h3><p>两个语句都会去<strong>字符串常量池</strong>检查是否已经存在”abc”，若有则直接使用，无则在常量池创建”abc”对象<br>不同的是，new String(“abc”)还有在堆中创建一个”abc”的对象实例。</p><img src="/2023/06/03/java-basic-interview-questions/String-abc.png" class=""><h3 id="String是不可变类，字符串拼接是如何实现的？"><a href="#String是不可变类，字符串拼接是如何实现的？" class="headerlink" title="String是不可变类，字符串拼接是如何实现的？"></a>String是不可变类，字符串拼接是如何实现的？</h3><p>String使用“+”的拼接操作时，会生成新的对象。</p><pre><code class="java">String a = &quot;hello &quot;;String b = &quot;world!&quot;;String ab = a + b;</code></pre><p>在<strong>JDK1.8之前</strong>，a和b初始化时位于字符串常量池，<strong>ab拼接后的对象位于堆中。如果拼接多次，就会生成多个中间对象</strong>。</p><img src="/2023/06/03/java-basic-interview-questions/String%E6%8B%BC%E6%8E%A5java8%E4%B9%8B%E5%89%8D.png" class=""><p>在<strong>JDK1.8之后</strong>，“+”的拼接方式会被优化为<strong>基于StringBuilder的append方法进行处理</strong>。Java会在编译期对“+”号处理。</p><img src="/2023/06/03/java-basic-interview-questions/String%E6%8B%BC%E6%8E%A5java8%E4%B9%8B%E5%90%8E.png" class=""><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><h3 id="Integer-a-x3D-127-Integer-b-x3D-127-Integer-c-x3D-128-Integer-d-x3D-128-是否相等？"><a href="#Integer-a-x3D-127-Integer-b-x3D-127-Integer-c-x3D-128-Integer-d-x3D-128-是否相等？" class="headerlink" title="Integer a &#x3D; 127, Integer b &#x3D; 127; Integer c &#x3D; 128, Integer d &#x3D; 128; 是否相等？"></a>Integer a &#x3D; 127, Integer b &#x3D; 127; Integer c &#x3D; 128, Integer d &#x3D; 128; 是否相等？</h3><p>a &#x3D;&#x3D; b –&gt; true;<br>c &#x3D;&#x3D; d –&gt; false;<br>原因：整型字面量的值在-128到127之间，<strong>自动装箱时不会new新的Integer对象</strong>，而是<strong>直接引用缓存池中的Integer对象</strong>。<br>注意是自动装箱！！！直接new Integer(127)也是新对象，那&#x3D;&#x3D;就为false;</p><pre><code class="java">Integer a = 127;Integer b = 127;Integer b1 = new Integer(127);System.out.println(a == b); // trueSystem.out.println(a == b1); // falseInteger c = 128;Integer d = 128;System.out.println(c == d); // false</code></pre><p>实现原理：int在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache</p><img src="/2023/06/03/java-basic-interview-questions/Interger-cache.png" class=""><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="JAVA中IO流分为几种？"><a href="#JAVA中IO流分为几种？" class="headerlink" title="JAVA中IO流分为几种？"></a>JAVA中IO流分为几种？</h3><ul><li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong></li><li>按照操作单元分，可以分为<strong>字节流</strong>和<strong>字符流</strong></li><li>按照流的角色分，可以分为<strong>节点流</strong>和<strong>处理流</strong></li></ul><p>JAVA IO流共涉及40多个类，主要从以下4个抽象基类派生出来</p><ul><li>InputStream&#x2F;Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流</li><li>OutputStream&#x2F;Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流</li></ul><p>ps：类比较多，后续整理下</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化就是把Java对象转为二进制流，方便存储和传输<br>反序列化就是吧二进制流恢复成对象</p><ul><li>Java序列化不包括静态变量。</li><li>如果有些<strong>变量</strong>不想序列化，使用transient关键字修饰<br>transient只能修饰变量，不能修饰类和方法</li></ul><h3 id="Serializable-有什么作用？"><a href="#Serializable-有什么作用？" class="headerlink" title="Serializable 有什么作用？"></a>Serializable 有什么作用？</h3><p>这个接口只是一个标记，没有具体作用，若不实现该接口，在某些序列化场景会失败</p><h3 id="serialVersionUID有什么作用？"><a href="#serialVersionUID有什么作用？" class="headerlink" title="serialVersionUID有什么作用？"></a>serialVersionUID有什么作用？</h3><p>serialVersionUID起验证作用</p><blockquote><p>private static final long serialVersionUID &#x3D; 1L;</p></blockquote><p>该ID其实就是用来验证序列化的对象和反序列化对象的对应ID是否一致<br>如果没有显示制定，编译器会根据类的相关信息自动生成一个<br><strong>注意：如果没有显示定义，在序列化一个对象后，在反序列化之前把类的结构改了，就会序列化失败</strong>，因为类变了，serialVersionUID就不一致了。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>参考：<a href="https://www.cnblogs.com/54chensongxia/p/12470672.html">https://www.cnblogs.com/54chensongxia/p/12470672.html</a></p><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p><p>使用方式：泛型类、泛型接口、泛型方法</p><pre><code class="java">// 泛型接口interface  ITest&lt;T&gt; &#123;    public T test();&#125;// 下面这几个都可以用class Test1&lt;String&gt; implements ITest&lt;String&gt; &#123;    @Override    public String test() &#123;        return (String) &quot;hello world&quot;;    &#125;&#125;class Test2&lt;String&gt; implements ITest &#123;    @Override    public String test() &#123;        return (String) &quot;hello world&quot;;    &#125;&#125;class Test3 implements ITest&lt;String&gt; &#123;    @Override    public String test() &#123;        return (String) &quot;hello world&quot;;    &#125;&#125;System.out.println((new Test1()).test());System.out.println((new Test2()).test());System.out.println((new Test3()).test());</code></pre><pre><code class="java">// 泛型类class Test4&lt;T&gt; &#123;    private T i;    public Test4(T k) &#123;        i = k;    &#125;    public T test() &#123;        return i;    &#125;&#125;System.out.println((new Test4&lt;String&gt;(&quot;hello world4&quot;)).test())</code></pre><pre><code class="java">// 泛型方法class Test5 &#123;    public static &lt;E&gt; void  printArray(E[] inputArr) &#123;        for ( E element : inputArr )&#123;            System.out.printf( &quot;%s &quot;, element );        &#125;        System.out.println();    &#125;    public &lt;E&gt; E test(E i) &#123;        return i;    &#125;&#125;Test5 test5 = new Test5();Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;test5.printArray(intArray);Character[] charArray = &#123; &#39;H&#39;, &#39;E&#39;, &#39;L&#39;, &#39;L&#39;, &#39;O&#39; &#125;;test5.printArray(charArray);System.out.println(test5.test(&quot;abc&quot;));System.out.println(test5.test(123));</code></pre><h3 id="泛型擦除是什么"><a href="#泛型擦除是什么" class="headerlink" title="泛型擦除是什么"></a>泛型擦除是什么</h3><p>泛型擦除：是指Java中的泛型只在编译期有效，<strong>在运行期间会被删除</strong>。</p><pre><code class="java">public class Test &#123;    // 会报重载错误    public void test(List&lt;String&gt; stringList)&#123;    &#125;    public void test(List&lt;Integer&gt; intList) &#123;    &#125;&#125;</code></pre><p>以上的代码会报重载错误，原因是：上面两个方法的参数是泛型参数，编译后会被泛型擦除，两个方法最后都是public void test(List stringList)，所以报重载错误。</p><p>在编译器编译后，泛型的转换规则如下：</p><ul><li>List、List 擦除后的类型为 List；</li><li>List[]、List[] 擦除后的类型为 List[];</li><li>List&lt;? extends E&gt;、List&lt;? super E&gt; 擦除后的类型为 List;</li><li>List&lt;T extends Serialzable &amp; Cloneable&gt; 擦除后类型为 List。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>反射就是Reflection，Java的反射是指程序在<strong>运行期</strong>可以拿到一个对象的所有信息。<br>原理：Java程序的执行分为编译和运行两步，<strong>编译后会生成字节码(.class)文件</strong>，JVM进行类加载的时候，会加载字节码文件，<strong>将类型相关的所有信息加载进方法区</strong>，反射就是去获取这些信息，然后进行操作，</p><h2 id="集合-List-Map-Set"><a href="#集合-List-Map-Set" class="headerlink" title="集合(List, Map, Set)"></a>集合(List, Map, Set)</h2><h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>ArrayList是基于数组的集合，在定义时大小是确定的，当容量超过数组长度就会触发扩容。<br>ArrayList的扩容是<strong>创建一个1.5倍的新数组</strong>，然后把原数组的值拷贝过去。</p><h3 id="ArrayList如何序列化？为什么要用transient修饰数组？"><a href="#ArrayList如何序列化？为什么要用transient修饰数组？" class="headerlink" title="ArrayList如何序列化？为什么要用transient修饰数组？"></a>ArrayList如何序列化？为什么要用transient修饰数组？</h3><p>ArrayList的序列化是通过<strong>readObject</strong>、<strong>writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<strong>ObjectOutputStream</strong>和<strong>ObjectInputStream</strong>来进行序列化和反序列化。</p><img src="/2023/06/03/java-basic-interview-questions/ArrayList-readObject-writeObject.png" class=""><p>元素数组elementData使用<strong>transient</strong>修饰，这样序列化的时候不会直接序列化元素数组，这是出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50可以不用序列化，所以通过自定义的<strong>readObject</strong>、<strong>writeObject</strong>提高了序列化和反序列化的效率，同时节省内存空间</p><img src="/2023/06/03/java-basic-interview-questions/arraylist-transient-elementData.png" class=""><h3 id="CopyOnWriteArrayList原理"><a href="#CopyOnWriteArrayList原理" class="headerlink" title="CopyOnWriteArrayList原理"></a>CopyOnWriteArrayList原理</h3><p>线程安全版本的ArrayList<br>原理：CopyOnWriteArrayList主要采用<strong>读写分离</strong>的并发策略，允许<strong>并发读</strong>，<strong>读操作时无锁的</strong>，性能较高。写操作时，首先<strong>将当前容器复制一份</strong>，然后在<strong>新副本</strong>上执行写操作(加锁写)，完成后<strong>将原容器的引用指向新容器</strong>。</p><img src="/2023/06/03/java-basic-interview-questions/CopyOnWriteArrayList.png" class=""><h3 id="说一说HashMap的数据结构"><a href="#说一说HashMap的数据结构" class="headerlink" title="说一说HashMap的数据结构"></a>说一说HashMap的数据结构</h3><ul><li><p>JDK1.7的数据结构是<strong>数组+链表</strong></p></li><li><p>JDK1.8的数据结构是<strong>数组+链表+红黑树</strong><br>数据结构图：</p><img src="/2023/06/03/java-basic-interview-questions/hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class=""></li><li><p>桶数组用于存放元素</p></li><li><p>链表用于解决冲突</p></li><li><p>红黑树用于提高查询效率</p></li></ul><h3 id="说一说HashMap的put的流程"><a href="#说一说HashMap的put的流程" class="headerlink" title="说一说HashMap的put的流程"></a>说一说HashMap的put的流程</h3><img src="/2023/06/03/java-basic-interview-questions/hashMap%E7%9A%84put%E6%B5%81%E7%A8%8B.png" class=""><pre><code class="java">/**     * Implements Map.put and related methods.     *     * @param hash hash for key     * @param key the key     * @param value the value to put     * @param onlyIfAbsent if true, don&#39;t change existing value     * @param evict if false, the table is in creation mode.     * @return previous value, or null if none     */    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;</code></pre><ol><li>首先进行哈希值的扰动，取得一个新的哈希值。</li></ol><pre><code class="java">static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</code></pre><ol start="2"><li>判断tab是否为空或者长度为0，如果是则进行扩容</li></ol><pre><code class="java">if ((tab = table) == null || (n = tab.length) == 0)    n = (tab = resize()).length;</code></pre><ol start="3"><li>根据哈希值计算下标</li><li>如果tab[i &#x3D; (n - 1) &amp; hash]为空，则直接存放数据</li><li>如果tab[i &#x3D; (n - 1) &amp; hash]不为空，则判断key是否相同，相同则直接覆盖</li><li>如果key不相同，判断tab[i &#x3D; (n - 1) &amp; hash]是否是树节点，如果是则向树中插入节点</li><li>如果tab[i &#x3D; (n - 1) &amp; hash]不是树节点，则将节点插入链表。</li><li>如果找到链表中相同key的节点，则覆盖节点</li><li>未找到链表中相同key的节点，则将节点插入到链表的尾节点，判断链表长度是否大于8，是则将链表转为红黑树。</li><li>最后判断是否超过阈值（threshold），超过则扩容</li></ol><h3 id="说一说HashMap怎么查找元素"><a href="#说一说HashMap怎么查找元素" class="headerlink" title="说一说HashMap怎么查找元素"></a>说一说HashMap怎么查找元素</h3><img src="/2023/06/03/java-basic-interview-questions/HashMap%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0.png" class=""><pre><code class="java">/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;.  (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it&#39;s also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */public V get(Object key) &#123;    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) &#123;        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) &#123;            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do &#123;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e = e.next) != null);        &#125;    &#125;    return null;&#125;</code></pre><ul><li>使用扰动函数，获取哈希值</li><li>计算数组下标，获取节点</li><li>当前节点和key匹配，直接返回</li><li>否则，判断当前节点是否为树节点，是则查找红黑树，</li><li>否则，遍历链表</li></ul><h3 id="HashMap的哈希扰动函数是如何设计的？"><a href="#HashMap的哈希扰动函数是如何设计的？" class="headerlink" title="HashMap的哈希扰动函数是如何设计的？"></a>HashMap的哈希扰动函数是如何设计的？</h3><p>HashMap的哈希函数先拿到key的hashCode，是一个<strong>32位</strong>的int类型的数组，然后让<strong>hashCode的高16位和低16位进行异或操作</strong>，这样设计<strong>降低了哈希碰撞的概率</strong></p><pre><code class="java">static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</code></pre><h3 id="为什么哈希-x2F-扰动函数能降低hash碰撞"><a href="#为什么哈希-x2F-扰动函数能降低hash碰撞" class="headerlink" title="为什么哈希&#x2F;扰动函数能降低hash碰撞"></a>为什么哈希&#x2F;扰动函数能降低hash碰撞</h3><p>因为HashMap中的模运算是把散列值和（数组长度-1）做“与&amp;”位运算，位运算比取余%运算快。HashMap的数组长度是<strong>2的整数幂</strong>，做与运算相当于将高位置0，只保留低位，这样只取低位容易产生碰撞，扰动函数混合了哈希码的高位和低位，加大了低位的随机性。（ps:TODO，画下图，不然转头又忘了。。。）</p><img src="/2023/06/03/java-basic-interview-questions/hashMap-%E6%A8%A1%E8%BF%90%E7%AE%97.png" class=""><h3 id="为什么HashMap的容量是2的倍数呢？"><a href="#为什么HashMap的容量是2的倍数呢？" class="headerlink" title="为什么HashMap的容量是2的倍数呢？"></a>为什么HashMap的容量是2的倍数呢？</h3><ul><li>第一，方便<strong>哈希取余</strong>，hash%数组大小 &#x3D;&#x3D; hash&amp;(数组大小-1) ，位运算的效率更高</li><li>第二，在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素转移到新的table中<br>（ps：感觉答的一般，后面补。。。）</li></ul><h3 id="HashMap扩容机制是怎么样的？"><a href="#HashMap扩容机制是怎么样的？" class="headerlink" title="HashMap扩容机制是怎么样的？"></a>HashMap扩容机制是怎么样的？</h3><ul><li>1.8之前是重新计算每个元素的哈希值</li><li>1.8之后，<strong>HashMap的初始容量是2的次幂</strong>，扩容后的长度是原来的两倍，则新的容量也是2的次幂，所以<strong>元素要么在原位置，要么在原位置再移动2的次幂</strong><br>(ps：todo，画图理解下，等下又忘了)</li></ul><h3 id="jdk1-8HashMap主要做了哪些优化？"><a href="#jdk1-8HashMap主要做了哪些优化？" class="headerlink" title="jdk1.8HashMap主要做了哪些优化？"></a>jdk1.8HashMap主要做了哪些优化？</h3><ul><li><p>数据结构<br>  数组+链表改成了数据+链表+红黑树<br>  原因：发生hash冲突时，元素会存入链表，联表太长的就转为红黑树，将<strong>时间复杂度从O(n)降为O(logn)</strong></p></li><li><p>链表插入方式<br>  头插法改成尾插法<br>  原因：1.7时头插法扩容时，会使链表发生反转，<strong>多线程环境下会产生环</strong></p></li><li><p>扩容resah<br>  1.7扩容时，需要对原数组中的元素进行重新hash定位在新数组的位置<br>  1.8扩容时，不重新计算，利用数组容量是2的次幂，扩容后也是2的次幂，新的位置不变或索引+旧的数组容量大小<br>  原因：提高扩容的效率，更快地扩容</p></li><li><p>扩容机制<br>  在插入时，1.7判断是否需要扩容再插入，1.8先进行插入，插入完成时再判断是否需要扩容</p></li><li><p>散列函数<br>  1.7做了四次移位和四次异或，jdk1.8只做一次<br>  原因：做4次的话，边际效用不大，改为一次，提升效率。</p></li></ul><h3 id="你能自己设计实现一个HashMap吗？（TODO，写代码）"><a href="#你能自己设计实现一个HashMap吗？（TODO，写代码）" class="headerlink" title="你能自己设计实现一个HashMap吗？（TODO，写代码）"></a>你能自己设计实现一个HashMap吗？（TODO，写代码）</h3><p>整体设计</p><ul><li>散列函数：hashCode + 除数留余法</li><li>冲突解决：链地址法</li><li>扩容：节点重新hash获取位置</li></ul><p>代码TODO</p><h3 id="HashMap是线程安全的吗？多线程下会有什么问题？"><a href="#HashMap是线程安全的吗？多线程下会有什么问题？" class="headerlink" title="HashMap是线程安全的吗？多线程下会有什么问题？"></a>HashMap是线程安全的吗？多线程下会有什么问题？</h3><p>HashMap是非线程安全的，在多线程下可能会出现以下问题</p><ul><li>多线程下扩容死循环。1.7中hashMap使用<strong>头插法</strong>插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。1.8采用<strong>尾插法</strong>插入元素，<strong>在扩容时保持链表元素原本的顺序</strong>，不会出现环形链表的问题。</li><li>多线程下put并发时，如果计算出来的位置相同，则前一key会被后一个key覆盖，从而导致元素丢失。</li><li>put和get并发时，可能导致get为null.线程1执行put时，元素个数超过threshold而导致rehash，线程2次时执行get，可能导致这个问题。</li></ul><h3 id="讲讲ConcurrentHashMap的具体实现？"><a href="#讲讲ConcurrentHashMap的具体实现？" class="headerlink" title="讲讲ConcurrentHashMap的具体实现？"></a>讲讲ConcurrentHashMap的具体实现？</h3><ul><li>1.7是使用<strong>分段锁</strong>的机制<br>ConcurrentHashMap里包含一个Segment数组，<strong>Segment数组继承自ReentrantLock</strong>，Segment数组包含HashEntry的数组，HashEntry是个链表结构，具有保存key、value的能力，并有指向下一个节点的指针。<br>其实相当于每个Segmment都是一个HashMap，默认长度为16，则支持16个线程的并发写，segment之间互不影响。</li></ul><p>put流程：<br>    1. 计算hash，定位到是哪一个segment，如果为空则初始化<br>    2. 使用ReentrantLock加锁，如果失败则自旋，自旋超过次数就阻塞获取，保证一定获取锁成功。<br>    3. 遍历HashEntry，key和hash一样就替换，否则插入链表（流程跟HashMap一样）</p><p>get流程：<br>    key通过hash定位到segment，再遍历链表定位到具体的元素上，因value是volatile，所以无需加锁</p><img src="/2023/06/03/java-basic-interview-questions/ConcurrentHashMap1.7-%E7%BB%93%E6%9E%84.png" class=""><ul><li>1.8 CAS + synchronized<br>1.8实现线程安全没有采用分段锁，它的数据结构和HashMap是一样的，数组+链表+红黑树，它实现线程安全的关键点在于put流程。<br>put流程：<img src="/2023/06/03/java-basic-interview-questions/ConCurrentHashMap-put%E6%B5%81%E7%A8%8B(1.8).png" class=""></li></ul><pre><code class="java">    /** Implementation for put and putIfAbsent */    final V putVal(K key, V value, boolean onlyIfAbsent) &#123;        if (key == null || value == null) throw new NullPointerException();        int hash = spread(key.hashCode()); // 1.计算Hash        int binCount = 0;        for (Node&lt;K,V&gt;[] tab = table;;) &#123; // 2.开始遍历数组            Node&lt;K,V&gt; f; int n, i, fh;            if (tab == null || (n = tab.length) == 0) // 3.数组为空，则进行初始化                tab = initTable();            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 4.tab[i]为空，则自旋写入                if (casTabAt(tab, i, null,                             new Node&lt;K,V&gt;(hash, key, value, null)))                    break;                   // no lock when adding to empty bin            &#125;            else if ((fh = f.hash) == MOVED) // 5.判断是否需要扩容                tab = helpTransfer(tab, f);            else &#123;                V oldVal = null;                synchronized (f) &#123; // 6. 加锁                     if (tabAt(tab, i) == f) &#123; // 7.hash碰撞                        if (fh &gt;= 0) &#123; // 8.是否是链表                            binCount = 1;                            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                                K ek;                                if (e.hash == hash &amp;&amp;                                    ((ek = e.key) == key ||                                     (ek != null &amp;&amp; key.equals(ek)))) &#123;                                    oldVal = e.val;                                    if (!onlyIfAbsent)                                        e.val = value;                                    break;                                &#125;                                Node&lt;K,V&gt; pred = e;                                if ((e = e.next) == null) &#123;                                    pred.next = new Node&lt;K,V&gt;(hash, key,                                                              value, null);                                    break;                                &#125;                            &#125;                        &#125;                        else if (f instanceof TreeBin) &#123; // 9.是否是红黑树                            Node&lt;K,V&gt; p;                            binCount = 2;                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                           value)) != null) &#123;                                oldVal = p.val;                                if (!onlyIfAbsent)                                    p.val = value;                            &#125;                        &#125;                    &#125;                &#125;                if (binCount != 0) &#123;                    if (binCount &gt;= TREEIFY_THRESHOLD) //10.长度超过 TREEIFY_THRESHOLD，则链表转红黑树                        treeifyBin(tab, i);                    if (oldVal != null)                        return oldVal;                    break;                &#125;            &#125;        &#125;        addCount(1L, binCount);        return null;    &#125;</code></pre><p>get流程：<br>跟HashMap基本相同</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 GitHub Pages + Hexo 搭建个人博客</title>
      <link href="/2023/06/02/hexo-and-github-pages/"/>
      <url>/2023/06/02/hexo-and-github-pages/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一 准备工作"></a>一 准备工作</h3><ol><li>注册Github</li><li>安装git</li><li>安装NodeJS</li></ol><h3 id="二-创建仓库"><a href="#二-创建仓库" class="headerlink" title="二 创建仓库"></a>二 创建仓库</h3><ol><li>进入仓库<img src="/2023/06/02/hexo-and-github-pages/into_repositories.png" class=""></li><li>点击 “NEW” 创建仓库<img src="/2023/06/02/hexo-and-github-pages/new_repositories.png" class=""></li><li>创建仓库，<strong>注意:</strong> 格式必须为&lt;用户名&gt;.github.io，ps:截图里的 lingpx 是因为我已经创建过仓库了，加个x演示下成功的状态<img src="/2023/06/02/hexo-and-github-pages/create_repositories.png" class=""></li><li>点击creating a new file 创建新文件，作为网站的主页<img src="/2023/06/02/hexo-and-github-pages/new_file.png" class=""></li><li>新文件的名字必须为index.html，填写后提交</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=&lt;device-width&gt;, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="6"><li>访问主页链接 <a href="https://lingp.github.io/">https://lingp.github.io/</a>，访问的地址就是 <strong>https:&#x2F;&#x2F;用户名.github.io</strong> ，以下可以看到自己的主页链接<img src="/2023/06/02/hexo-and-github-pages/site.png" class=""></li></ol><h3 id="三-安装Hexo"><a href="#三-安装Hexo" class="headerlink" title="三 安装Hexo"></a>三 安装Hexo</h3><p>官网地址：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><ol><li><p>安装</p><blockquote><p>npm install hexo-cli -g</p></blockquote></li><li><p>查看版本</p><blockquote><p>hexo -v</p></blockquote></li><li><p>创建项目</p><blockquote><p>hexo init hexo-blog<br>cd hexo-blog<br>npm install</p></blockquote></li><li><p>本地启动</p><blockquote><p>hexo g<br>hexo server<br>或者简写<br>hexo g &amp; s</p></blockquote></li><li><p>访问本地链接 <a href="http://localhost:4000/">http://localhost:4000</a></p></li></ol><h3 id="四-更换主题"><a href="#四-更换主题" class="headerlink" title="四 更换主题"></a>四 更换主题</h3><p>官网主题地址：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>我这边选用的是”3-hexo”主题，可以根据自己喜欢的主题更换<br>主题地址：<a href="https://github.com/yelog/hexo-theme-3-hexo">https://github.com/yelog/hexo-theme-3-hexo</a><br><strong>3-hexo使用说明</strong>: <a href="https://yelog.org/2017/03/23/3-hexo-instruction/">https://yelog.org/2017/03/23/3-hexo-instruction/</a></p><img src="/2023/06/02/hexo-and-github-pages/theme.png" class=""><p>安装介绍</p><blockquote><p>git clone <a href="https://github.com/yelog/hexo-theme-3-hexo.git">https://github.com/yelog/hexo-theme-3-hexo.git</a> themes&#x2F;3-hexo</p></blockquote><blockquote><p>可以把<strong>themes&#x2F;3-hexo</strong>下的_config.yml，复制到hexo-blog <em><strong>根目录</strong></em>下并改名_config.3-hexo.yml，后续个性化可以改这个文件，当然也可以直接改themes&#x2F;3-hexo下的_config.yml</p></blockquote><blockquote><p>修改hexo-blog <em><strong>根目录</strong></em> 的_config.yml，如下<br>theme: 3-hexo</p></blockquote><blockquote><p>本地启动：hexo g -d &amp; hexo s</p></blockquote><h3 id="五-创建文章"><a href="#五-创建文章" class="headerlink" title="五 创建文章"></a>五 创建文章</h3><p>修改hexo-blog <em><strong>根目录</strong></em> 的_config.yml的配置，该配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件，如下</p><blockquote><p>post_asset_folder: true</p></blockquote><p>执行如下命令创建新文章</p><blockquote><p>hexo new post test_article</p></blockquote><p>引入图片，参考:<a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p><pre><code>&#123;% asset_img test_show.png %&#125;</code></pre><img src="/2023/06/02/hexo-and-github-pages/test_show.png" class=""><p>效果图：</p><img src="/2023/06/02/hexo-and-github-pages/res-show.png" class=""><h3 id="六-个性化"><a href="#六-个性化" class="headerlink" title="六 个性化"></a>六 个性化</h3><p>参考：<strong>3-hexo使用说明</strong>: <a href="https://yelog.org/2017/03/23/3-hexo-instruction/">https://yelog.org/2017/03/23/3-hexo-instruction/</a></p><h3 id="七-发布到GitHub-Pages"><a href="#七-发布到GitHub-Pages" class="headerlink" title="七 发布到GitHub Pages"></a>七 发布到GitHub Pages</h3><p>方式一<br>安装hexo-deployer-git</p><blockquote><p>npm install hexo-deployer-git</p></blockquote><blockquote><p>修改<strong>根目录</strong>下的_config.yml的配置<br>deploy:<br>  type: git<br>  repo: <a href="https://github.com/lingp/lingp.github.io.git">https://github.com/lingp/lingp.github.io.git</a><br>  branch: master<br>  token: xxx</p></blockquote><p>token的获取方式</p><ol><li>进入setting页面<img src="/2023/06/02/hexo-and-github-pages/token_setting_first.png" class=""></li><li>右下角<img src="/2023/06/02/hexo-and-github-pages/token_setting_second.png" class=""></li><li>创建token<img src="/2023/06/02/hexo-and-github-pages/token_setting_third.png" class=""></li><li>复制token<img src="/2023/06/02/hexo-and-github-pages/token_setting_four.png" class=""></li></ol><p>部署到Github</p><blockquote><p>hexo g -d</p></blockquote><p>方式二</p><p>直接将public目录中的文件和目录推到至GitHub仓库和分支</p><img src="/2023/06/02/hexo-and-github-pages/push.png" class=""><hr><p>参考：</p><ol><li>hexo官网：<a href="https://hexo.io/zh-cn">https://hexo.io/zh-cn</a></li><li>hexo主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li><li>搭建教程：<a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a></li><li>GitHub Pages：<a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/about-github-pages">https://docs.github.com/zh/pages/getting-started-with-github-pages/about-github-pages</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2023/06/02/my-blog-build-remark/"/>
      <url>/2023/06/02/my-blog-build-remark/</url>
      
        <content type="html"><![CDATA[<p>hello world</p><img src="/2023/06/02/my-blog-build-remark/view_photo.png" class="">]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> fluid </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
