<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>java基础面试题 | 努力奋斗</title>
  <meta name="keywords" content=" 后端 , java , 面试题 ">
  <meta name="description" content="java基础面试题 | 努力奋斗">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="目前只整理我自己觉得比较常问的题，补充ing[toc] 基础语法1.Java有哪些数据类型？Java数据类型分为两种：基本数据类型和引用数据类型   基本数据类型分为：  数值型 整数类型（byte、short、int、long） 浮点类型（float、double） 字符型（char） 布尔型（boolean）  Java 基本数据类型范围和默认值：    基本类型 位数 字节 默认值    i">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础面试题">
<meta property="og:url" content="http://example.com/2023/06/03/java-basic-interview-questions/index.html">
<meta property="og:site_name" content="努力奋斗">
<meta property="og:description" content="目前只整理我自己觉得比较常问的题，补充ing[toc] 基础语法1.Java有哪些数据类型？Java数据类型分为两种：基本数据类型和引用数据类型   基本数据类型分为：  数值型 整数类型（byte、short、int、long） 浮点类型（float、double） 字符型（char） 布尔型（boolean）  Java 基本数据类型范围和默认值：    基本类型 位数 字节 默认值    i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/Object-equals.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/String-abc.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/String%E6%8B%BC%E6%8E%A5java8%E4%B9%8B%E5%89%8D.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/String%E6%8B%BC%E6%8E%A5java8%E4%B9%8B%E5%90%8E.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/Interger-cache.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/ArrayList-readObject-writeObject.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/arraylist-transient-elementData.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/CopyOnWriteArrayList.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/hashMap%E7%9A%84put%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/HashMap%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/hashMap-%E6%A8%A1%E8%BF%90%E7%AE%97.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/ConcurrentHashMap1.7-%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/ConCurrentHashMap-put%E6%B5%81%E7%A8%8B(1.8).png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/ThreadLocal%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/JMM.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/synchronized%E4%BB%A3%E7%A0%81%E5%9D%97.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/synchronized%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/Java%E5%A0%86-%E4%BB%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%A7%92%E5%BA%A6%E5%88%92%E5%88%86.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/jdk1.7-jdk1.8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E5%A0%86%E6%8A%A2%E5%8D%A0.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E5%8F%AF%E8%BE%BE%E6%80%A7.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E6%96%B0%E7%94%9F%E4%BB%A3.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/CMS.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/G1.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/G1%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2023/06/03/java-basic-interview-questions/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2023-06-03T08:16:21.000Z">
<meta property="article:modified_time" content="2023-07-20T08:57:34.828Z">
<meta property="article:author" content="zhan peng">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="java">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/06/03/java-basic-interview-questions/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>zhan peng</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/lingp"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:820541664@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(4)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="工具">
                        <i class="fold iconfont icon-right"></i>
                        
                        工具
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="工具<--->hexo">
                                        
                                        hexo
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后端">
                        <i class="fold iconfont icon-right"></i>
                        
                        后端
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="后端<--->java">
                                        
                                        java
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="前端">
                        <i class="fold iconfont icon-right"></i>
                        
                        前端
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="前端<--->uniapp">
                                        
                                        uniapp
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="4">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>后端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面试题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>fluid</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>uniapp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vue3</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 前端 uniapp "
           href="/2023/06/06/uniapp-problem/"
           data-tag="uniapp,vue3"
           data-author="" >
            <span class="post-title" title="使用uniapp遇到的问题">使用uniapp遇到的问题</span>
            <span class="post-date" title="2023-06-06 22:38:41">2023/06/06</span>
        </a>
        
        
        <a  class="全部文章 后端 java "
           href="/2023/06/03/java-basic-interview-questions/"
           data-tag="后端,java,面试题"
           data-author="" >
            <span class="post-title" title="java基础面试题">java基础面试题</span>
            <span class="post-date" title="2023-06-03 16:16:21">2023/06/03</span>
        </a>
        
        
        <a  class="全部文章 工具 hexo "
           href="/2023/06/02/hexo-and-github-pages/"
           data-tag="hexo,fluid"
           data-author="" >
            <span class="post-title" title="基于 GitHub Pages + Hexo 搭建个人博客">基于 GitHub Pages + Hexo 搭建个人博客</span>
            <span class="post-date" title="2023-06-02 17:02:02">2023/06/02</span>
        </a>
        
        
        <a  class="全部文章 工具 hexo "
           href="/2023/06/02/my-blog-build-remark/"
           data-tag="hexo,fluid"
           data-author="" >
            <span class="post-title" title="测试">测试</span>
            <span class="post-date" title="2023-06-02 17:02:02">2023/06/02</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-java-basic-interview-questions" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">java基础面试题</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="后端">后端</a> > 
            
            <a  data-rel="后端&lt;---&gt;java">java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">后端</a>
            
            <a class="color5">java</a>
            
            <a class="color4">面试题</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-07-20 16:57:34'>2023-06-03 16:16</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.Java有哪些数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-switch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-byte-x2F-long-x2F-String-%E4%B8%8A%EF%BC%9F"><span class="toc-text">2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">final 关键字有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;和 equals 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E4%B8%8E-equals"><span class="toc-text">hashCode 与 equals?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">深拷贝和浅拷贝？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8CStringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String和StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-str1-x3D-new-String-%E2%80%9Cabc%E2%80%9D-%E5%92%8CString-str2-x3D-%E2%80%9Dabc%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String str1&#x3D;new String(“abc”)和String str2&#x3D;”abc”的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">String是不可变类，字符串拼接是如何实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-text">Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-a-x3D-127-Integer-b-x3D-127-Integer-c-x3D-128-Integer-d-x3D-128-%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">Integer a &#x3D; 127, Integer b &#x3D; 127; Integer c &#x3D; 128, Integer d &#x3D; 128; 是否相等？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E4%B8%ADIO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">JAVA中IO流分为几种？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是序列化？什么是反序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Serializable 有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialVersionUID%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">serialVersionUID有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">泛型擦除是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">什么是反射？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88-List-Map-Set"><span class="toc-text">集合(List, Map, Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%A6%82%E4%BD%95%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8transient%E4%BF%AE%E9%A5%B0%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-text">ArrayList如何序列化？为什么要用transient修饰数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList%E5%8E%9F%E7%90%86"><span class="toc-text">CopyOnWriteArrayList原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">说一说HashMap的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E7%9A%84put%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">说一说HashMap的put的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E6%80%8E%E4%B9%88%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-text">说一说HashMap怎么查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E5%93%88%E5%B8%8C%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">HashMap的哈希扰动函数是如何设计的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-x2F-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8D%E4%BD%8Ehash%E7%A2%B0%E6%92%9E"><span class="toc-text">为什么哈希&#x2F;扰动函数能降低hash碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E5%AE%B9%E9%87%8F%E6%98%AF2%E7%9A%84%E5%80%8D%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么HashMap的容量是2的倍数呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">HashMap扩容机制是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk1-8HashMap%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">jdk1.8HashMap主要做了哪些优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHashMap%E5%90%97%EF%BC%9F%EF%BC%88TODO%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-text">你能自己设计实现一个HashMap吗？（TODO，写代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">HashMap是线程安全的吗？多线程下会有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2ConcurrentHashMap%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">讲讲ConcurrentHashMap的具体实现？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">ThreadLocal内存泄露的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">ThreadLocalMap的结构是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%9F"><span class="toc-text">ThreadLocalMap怎么解决Hash冲突的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">说说对JAVA内存模型(JMM)的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">volatile实现原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">synchronized的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">synchronized的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-text">synchronized如何实现可见性、有序性、可重入性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">AQS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">CAS是什么？有什么问题？如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="toc-text">线程池有哪些参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">线程池的拒绝策略有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4execute%E5%92%8Csubmit%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">线程池提交execute和submit有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">常见的线程池有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">线程池异常怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">线程池有几种状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-text">说说JVM的内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JDK1-7%E5%92%8CJDK1-8%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">说说JDK1.7和JDK1.8内存区域的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">什么是指针碰撞？什么是空闲列表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E9%87%8Cnew%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%A0%86%E6%98%AF%E5%90%A6%E4%BC%9A%E5%8F%91%E7%94%9F%E6%8A%A2%E5%8D%A0%EF%BC%9FJVM%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">JVM里new对象时，堆是否会发生抢占？JVM是怎么来保证线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">导致内存泄漏的原因有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%BB%8D%E7%84%B6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">如何判断对象仍然存活？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">常用垃圾收集算法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%96%B0%E7%94%9F%E4%BB%A3%E5%8C%BA%E5%9F%9F"><span class="toc-text">说一说新生代区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-text">Full GC什么时候触发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-text">对象什么时候进入老年代？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常用的垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">说一说CMS垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">说一说G1垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88CMS%E6%9C%89%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BF%98%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5G1"><span class="toc-text">为什么CMS有了，为何还需要引入G1?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%90%97%EF%BC%9F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">对象一定分配在堆中吗？逃逸分析技术是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">说一说类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">说一说类加载的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">类加载器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">什么是双亲委派机制</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em><strong>目前只整理我自己觉得比较常问的题，补充ing</strong></em><br><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.Java有哪些数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-switch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-byte-x2F-long-x2F-String-%E4%B8%8A%EF%BC%9F"><span class="toc-text">2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">final 关键字有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;和 equals 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E4%B8%8E-equals"><span class="toc-text">hashCode 与 equals?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">深拷贝和浅拷贝？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8CStringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String和StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-str1-x3D-new-String-%E2%80%9Cabc%E2%80%9D-%E5%92%8CString-str2-x3D-%E2%80%9Dabc%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">String str1&#x3D;new String(“abc”)和String str2&#x3D;”abc”的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">String是不可变类，字符串拼接是如何实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-text">Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-a-x3D-127-Integer-b-x3D-127-Integer-c-x3D-128-Integer-d-x3D-128-%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">Integer a &#x3D; 127, Integer b &#x3D; 127; Integer c &#x3D; 128, Integer d &#x3D; 128; 是否相等？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E4%B8%ADIO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">JAVA中IO流分为几种？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是序列化？什么是反序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Serializable 有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialVersionUID%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">serialVersionUID有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">泛型擦除是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-text">什么是反射？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88-List-Map-Set"><span class="toc-text">集合(List, Map, Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%A6%82%E4%BD%95%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8transient%E4%BF%AE%E9%A5%B0%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-text">ArrayList如何序列化？为什么要用transient修饰数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList%E5%8E%9F%E7%90%86"><span class="toc-text">CopyOnWriteArrayList原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">说一说HashMap的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E7%9A%84put%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">说一说HashMap的put的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4HashMap%E6%80%8E%E4%B9%88%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-text">说一说HashMap怎么查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E5%93%88%E5%B8%8C%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">HashMap的哈希扰动函数是如何设计的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-x2F-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8D%E4%BD%8Ehash%E7%A2%B0%E6%92%9E"><span class="toc-text">为什么哈希&#x2F;扰动函数能降低hash碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E5%AE%B9%E9%87%8F%E6%98%AF2%E7%9A%84%E5%80%8D%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么HashMap的容量是2的倍数呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">HashMap扩容机制是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk1-8HashMap%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">jdk1.8HashMap主要做了哪些优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHashMap%E5%90%97%EF%BC%9F%EF%BC%88TODO%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-text">你能自己设计实现一个HashMap吗？（TODO，写代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">HashMap是线程安全的吗？多线程下会有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2ConcurrentHashMap%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">讲讲ConcurrentHashMap的具体实现？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">ThreadLocal内存泄露的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">ThreadLocalMap的结构是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%9F"><span class="toc-text">ThreadLocalMap怎么解决Hash冲突的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">说说对JAVA内存模型(JMM)的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">volatile实现原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">synchronized的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">synchronized的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-text">synchronized如何实现可见性、有序性、可重入性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">AQS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">CAS是什么？有什么问题？如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="toc-text">线程池有哪些参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">线程池的拒绝策略有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4execute%E5%92%8Csubmit%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">线程池提交execute和submit有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">常见的线程池有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">线程池异常怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">线程池有几种状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-text">说说JVM的内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JDK1-7%E5%92%8CJDK1-8%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">说说JDK1.7和JDK1.8内存区域的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-text">什么是指针碰撞？什么是空闲列表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E9%87%8Cnew%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%A0%86%E6%98%AF%E5%90%A6%E4%BC%9A%E5%8F%91%E7%94%9F%E6%8A%A2%E5%8D%A0%EF%BC%9FJVM%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">JVM里new对象时，堆是否会发生抢占？JVM是怎么来保证线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">导致内存泄漏的原因有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%BB%8D%E7%84%B6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">如何判断对象仍然存活？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">常用垃圾收集算法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%96%B0%E7%94%9F%E4%BB%A3%E5%8C%BA%E5%9F%9F"><span class="toc-text">说一说新生代区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-text">Full GC什么时候触发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-text">对象什么时候进入老年代？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常用的垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">说一说CMS垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">说一说G1垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88CMS%E6%9C%89%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BD%95%E8%BF%98%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5G1"><span class="toc-text">为什么CMS有了，为何还需要引入G1?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%90%97%EF%BC%9F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">对象一定分配在堆中吗？逃逸分析技术是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">说一说类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">说一说类加载的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">类加载器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">什么是双亲委派机制</span></a></li></ol></li></ol></div></p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="1-Java有哪些数据类型？"><a href="#1-Java有哪些数据类型？" class="headerlink" title="1.Java有哪些数据类型？"></a>1.Java有哪些数据类型？</h3><p>Java数据类型分为两种：基本数据类型和引用数据类型</p>
<img src="/2023/06/03/java-basic-interview-questions/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class="">

<p>基本数据类型分为：</p>
<ol>
<li>数值型</li>
<li>整数类型（byte、short、int、long）</li>
<li>浮点类型（float、double）</li>
<li>字符型（char）</li>
<li>布尔型（boolean）</li>
</ol>
<p>Java 基本数据类型范围和默认值：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
<td>0d</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<p>引用数据类型：</p>
<ol>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（[]）</li>
</ol>
<p><strong>注意：string不是基本的数据类型</strong></p>
<h3 id="2-switch-是否能作用在-byte-x2F-long-x2F-String-上？"><a href="#2-switch-是否能作用在-byte-x2F-long-x2F-String-上？" class="headerlink" title="2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？"></a>2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？</h3><p>Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。<br>从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。<br>从 Java 7 开始，expr 还可以是字符串(String)，但是<strong>长整型(long)在目前所有的版本中都是不可以的</strong>。<br><em>ps: 好冷门的题。。。</em></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="final-关键字有什么作用？"><a href="#final-关键字有什么作用？" class="headerlink" title="final 关键字有什么作用？"></a>final 关键字有什么作用？</h3><p>final，表示不可变的意思，可用于修饰类、属性和方法</p>
<ol>
<li>被final修饰的类<strong>不可以被继承</strong></li>
<li>被final修饰的方法<strong>不可以被重写</strong></li>
<li>被final修饰的变量不可变，被final修饰的变量必须被<strong>显式地指定初始值</strong>，还得注意的是，<strong>这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变</strong>。</li>
</ol>
<h3 id="x3D-x3D-和-equals-的区别？"><a href="#x3D-x3D-和-equals-的区别？" class="headerlink" title="&#x3D;&#x3D;和 equals 的区别？"></a>&#x3D;&#x3D;和 equals 的区别？</h3><p>&#x3D;&#x3D;：作用是判断两个对象的<strong>地址</strong>是否相等。即判断两个对象是不是同一个对象，<strong>基本数据类型比较的是值，引用类型比较的是内存地址</strong></p>
<p>equals：</p>
<ol>
<li>默认情况下，类没有覆盖equals()方法，则通过equals比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是内存地址</li>
<li>自定义的情况：类覆盖equals()方法，<strong>一般是比较两个对象的内容是否相同</strong>，自定义了一个相等的标准，也就是两个对象的值是否相等</li>
</ol>
<pre><code class="java">public class Person &#123;
   private String name;
   private String age;
   @Override
   public boolean equals(Object o) &#123;
       if (this == o) return true;
       if (!(o instanceof Person)) return false;
       Person person = (Person) o;
       return Objects.equals(age, person.age) &amp;&amp;
               Objects.equals(name, person.name);
   &#125;

   @Override
   public int hashCode() &#123;
       return Objects.hash(age, name);
   &#125;
&#125;
</code></pre>
<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals?"></a>hashCode 与 equals?</h3><p><em><strong>面试常问：你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode ⽅法？</strong></em></p>
<ol>
<li><p>什么是hashCode?<br> 1.1 hashCode()的作用是获取哈希码，即散列码，实际上它返回一个<strong>int整数</strong>，定义在Object类中，是一个<strong>本地方法</strong>，这个方法常用来<strong>将对象的内存地址转为整数</strong>后返回</p>
<pre><code class="java">public native int hashCode();
</code></pre>
<p> 1.2 哈希码主要在哈希表这类集合映射的时候用到，哈希表存储的是键值对(key-value)，它的特点是：能根据“键”快速的映射到对应的“值”。这其中就利⽤到了哈希码！  </p>
<p> 1.3 例如：HashMap 怎么把 key 映射到对应的 value 上呢？用的就是<strong>哈希取余法</strong>，也就是拿哈希码和存储元素的数组的长度取余，获取 key 对应的 value 所在的下标位置。</p>
</li>
<li><p>为什么重写 equals 时必须重写 hashCode ⽅法？(参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7024410950841139207">https://juejin.cn/post/7024410950841139207</a>)<br> 如果两个对象相等，则hashcode一定也是相同的。<br> 但反之，两个对象有相同的hashcode值，它们也不一定相等。(hash碰撞)</p>
<ul>
<li><p>每当重写equals时，通常都需要重写hashCode方法，以维护hashCode方法的一般约定，即相等的对象必须具有相等的哈希码。（注意：这里来源于Object.equals的注释）</p>
 <img src="/2023/06/03/java-basic-interview-questions/Object-equals.png" class="">
</li>
<li><p>例：Java中的String类，这个类在Java集合中用到很多，例如我们平时使用的HashMap&#x2F;Set等等集合，都是经常性的使用String类型去当作key来进行使用的。String重写了equals和hashcode</p>
<ul>
<li><p>如果String没有重写equals，也就是继承了Object类的equals方法的话，则如果String类型为key的时候，<strong>相同的字符串，也可能会被当成两个不一样的key</strong>，从而难以辨别。</p>
</li>
<li><p>如果String重写了equals，没有重写hashCode。那么也会出现，同一个key出现在不同的位置，因为集合中常用哈希函数来计算key的位置，在没有重写hashCode的情况下，则<strong>同一个key会出现hashCode值不同而导致位置不同</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="深拷贝和浅拷贝？"><a href="#深拷贝和浅拷贝？" class="headerlink" title="深拷贝和浅拷贝？"></a>深拷贝和浅拷贝？</h3><ul>
<li>浅拷贝：仅拷贝被拷贝对象的成员变量的值，也就是<strong>基本数据类型变量的值</strong>，和<strong>引用数据类型变量的地址值</strong>，而对于引用类型变量指向的堆中的对象不会拷贝</li>
<li>深拷贝：完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份</li>
</ul>
<p>深拷贝是安全的，浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象。</p>
<p>举例：现在有个Order对象，成员变量，有个基本数据类型order_no，还有一个引用数据类型products</p>
<img src="/2023/06/03/java-basic-interview-questions/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D.png" class="">

<blockquote>
<p>浅拷贝如何实现呢？</p>
</blockquote>
<p> Object 类提供的 clone()方法可以非常简单地实现对象的浅拷贝。</p>
<blockquote>
<p>深拷贝如何实现呢？</p>
</blockquote>
<ol>
<li>重写克隆方法：重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归。</li>
<li>序列化：可以先将<strong>原对象序列化</strong>，再<strong>反序列化成拷贝对象</strong>。</li>
</ol>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String和StringBuilder、StringBuffer的区别"><a href="#String和StringBuilder、StringBuffer的区别" class="headerlink" title="String和StringBuilder、StringBuffer的区别"></a>String和StringBuilder、StringBuffer的区别</h3><ul>
<li>String: String的值被创建后就不能修改，<strong>任何对String对象的修改都会引发新的String对象的生成</strong></li>
<li>StringBuffer：跟String类似，但是<strong>值可以被修改</strong>，则不生成新的对象，使用synchronized来保证线程安全</li>
<li>StringBuilder：StringBuffer的<strong>非线程安全版</strong>，性能上更高一些</li>
</ul>
<h3 id="String-str1-x3D-new-String-“abc”-和String-str2-x3D-”abc”的区别"><a href="#String-str1-x3D-new-String-“abc”-和String-str2-x3D-”abc”的区别" class="headerlink" title="String str1&#x3D;new String(“abc”)和String str2&#x3D;”abc”的区别"></a>String str1&#x3D;new String(“abc”)和String str2&#x3D;”abc”的区别</h3><p>两个语句都会去<strong>字符串常量池</strong>检查是否已经存在”abc”，若有则直接使用，无则在常量池创建”abc”对象<br>不同的是，new String(“abc”)还有在堆中创建一个”abc”的对象实例。</p>
<img src="/2023/06/03/java-basic-interview-questions/String-abc.png" class="">


<h3 id="String是不可变类，字符串拼接是如何实现的？"><a href="#String是不可变类，字符串拼接是如何实现的？" class="headerlink" title="String是不可变类，字符串拼接是如何实现的？"></a>String是不可变类，字符串拼接是如何实现的？</h3><p>String使用“+”的拼接操作时，会生成新的对象。</p>
<pre><code class="java">String a = &quot;hello &quot;;
String b = &quot;world!&quot;;
String ab = a + b;
</code></pre>
<p>在<strong>JDK1.8之前</strong>，a和b初始化时位于字符串常量池，<strong>ab拼接后的对象位于堆中。如果拼接多次，就会生成多个中间对象</strong>。</p>
<img src="/2023/06/03/java-basic-interview-questions/String%E6%8B%BC%E6%8E%A5java8%E4%B9%8B%E5%89%8D.png" class="">

<p>在<strong>JDK1.8之后</strong>，“+”的拼接方式会被优化为<strong>基于StringBuilder的append方法进行处理</strong>。Java会在编译期对“+”号处理。</p>
<img src="/2023/06/03/java-basic-interview-questions/String%E6%8B%BC%E6%8E%A5java8%E4%B9%8B%E5%90%8E.png" class="">

<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><h3 id="Integer-a-x3D-127-Integer-b-x3D-127-Integer-c-x3D-128-Integer-d-x3D-128-是否相等？"><a href="#Integer-a-x3D-127-Integer-b-x3D-127-Integer-c-x3D-128-Integer-d-x3D-128-是否相等？" class="headerlink" title="Integer a &#x3D; 127, Integer b &#x3D; 127; Integer c &#x3D; 128, Integer d &#x3D; 128; 是否相等？"></a>Integer a &#x3D; 127, Integer b &#x3D; 127; Integer c &#x3D; 128, Integer d &#x3D; 128; 是否相等？</h3><p>a &#x3D;&#x3D; b –&gt; true;<br>c &#x3D;&#x3D; d –&gt; false;<br>原因：整型字面量的值在-128到127之间，<strong>自动装箱时不会new新的Integer对象</strong>，而是<strong>直接引用缓存池中的Integer对象</strong>。<br>注意是自动装箱！！！直接new Integer(127)也是新对象，那&#x3D;&#x3D;就为false;</p>
<pre><code class="java">Integer a = 127;
Integer b = 127;
Integer b1 = new Integer(127);

System.out.println(a == b); // true
System.out.println(a == b1); // false

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // false
</code></pre>
<p>实现原理：int在自动装箱的时候会调用Integer.valueOf，进而用到了IntegerCache</p>
<img src="/2023/06/03/java-basic-interview-questions/Interger-cache.png" class="">

<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="JAVA中IO流分为几种？"><a href="#JAVA中IO流分为几种？" class="headerlink" title="JAVA中IO流分为几种？"></a>JAVA中IO流分为几种？</h3><ul>
<li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong></li>
<li>按照操作单元分，可以分为<strong>字节流</strong>和<strong>字符流</strong></li>
<li>按照流的角色分，可以分为<strong>节点流</strong>和<strong>处理流</strong></li>
</ul>
<p>JAVA IO流共涉及40多个类，主要从以下4个抽象基类派生出来</p>
<ul>
<li>InputStream&#x2F;Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流</li>
<li>OutputStream&#x2F;Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流</li>
</ul>
<p>ps：类比较多，后续整理下</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化就是把Java对象转为二进制流，方便存储和传输<br>反序列化就是吧二进制流恢复成对象</p>
<ul>
<li>Java序列化不包括静态变量。</li>
<li>如果有些<strong>变量</strong>不想序列化，使用transient关键字修饰<br>transient只能修饰变量，不能修饰类和方法</li>
</ul>
<h3 id="Serializable-有什么作用？"><a href="#Serializable-有什么作用？" class="headerlink" title="Serializable 有什么作用？"></a>Serializable 有什么作用？</h3><p>这个接口只是一个标记，没有具体作用，若不实现该接口，在某些序列化场景会失败</p>
<h3 id="serialVersionUID有什么作用？"><a href="#serialVersionUID有什么作用？" class="headerlink" title="serialVersionUID有什么作用？"></a>serialVersionUID有什么作用？</h3><p>serialVersionUID起验证作用</p>
<blockquote>
<p>private static final long serialVersionUID &#x3D; 1L;</p>
</blockquote>
<p>该ID其实就是用来验证序列化的对象和反序列化对象的对应ID是否一致<br>如果没有显示制定，编译器会根据类的相关信息自动生成一个<br><strong>注意：如果没有显示定义，在序列化一个对象后，在反序列化之前把类的结构改了，就会序列化失败</strong>，因为类变了，serialVersionUID就不一致了。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12470672.html">https://www.cnblogs.com/54chensongxia/p/12470672.html</a></p>
<p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p>
<p>泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>使用方式：泛型类、泛型接口、泛型方法</p>
<pre><code class="java">// 泛型接口
interface  ITest&lt;T&gt; &#123;
    public T test();
&#125;

// 下面这几个都可以用
class Test1&lt;String&gt; implements ITest&lt;String&gt; &#123;
    @Override
    public String test() &#123;
        return (String) &quot;hello world&quot;;
    &#125;
&#125;

class Test2&lt;String&gt; implements ITest &#123;
    @Override
    public String test() &#123;
        return (String) &quot;hello world&quot;;
    &#125;
&#125;

class Test3 implements ITest&lt;String&gt; &#123;
    @Override
    public String test() &#123;
        return (String) &quot;hello world&quot;;
    &#125;
&#125;

System.out.println((new Test1()).test());
System.out.println((new Test2()).test());
System.out.println((new Test3()).test());
</code></pre>
<pre><code class="java">// 泛型类
class Test4&lt;T&gt; &#123;
    private T i;

    public Test4(T k) &#123;
        i = k;
    &#125;

    public T test() &#123;
        return i;
    &#125;
&#125;

System.out.println((new Test4&lt;String&gt;(&quot;hello world4&quot;)).test())
</code></pre>
<pre><code class="java">// 泛型方法
class Test5 &#123;
    public static &lt;E&gt; void  printArray(E[] inputArr) &#123;
        for ( E element : inputArr )&#123;
            System.out.printf( &quot;%s &quot;, element );
        &#125;
        System.out.println();
    &#125;

    public &lt;E&gt; E test(E i) &#123;
        return i;
    &#125;
&#125;


Test5 test5 = new Test5();
Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;
test5.printArray(intArray);
Character[] charArray = &#123; &#39;H&#39;, &#39;E&#39;, &#39;L&#39;, &#39;L&#39;, &#39;O&#39; &#125;;
test5.printArray(charArray);

System.out.println(test5.test(&quot;abc&quot;));
System.out.println(test5.test(123));
</code></pre>
<h3 id="泛型擦除是什么"><a href="#泛型擦除是什么" class="headerlink" title="泛型擦除是什么"></a>泛型擦除是什么</h3><p>泛型擦除：是指Java中的泛型只在编译期有效，<strong>在运行期间会被删除</strong>。</p>
<pre><code class="java">public class Test &#123;
    // 会报重载错误
    public void test(List&lt;String&gt; stringList)&#123;
    &#125;
    public void test(List&lt;Integer&gt; intList) &#123;
    &#125;
&#125;
</code></pre>
<p>以上的代码会报重载错误，原因是：上面两个方法的参数是泛型参数，编译后会被泛型擦除，两个方法最后都是public void test(List stringList)，所以报重载错误。</p>
<p>在编译器编译后，泛型的转换规则如下：</p>
<ul>
<li>List、List 擦除后的类型为 List；</li>
<li>List[]、List[] 擦除后的类型为 List[];</li>
<li>List&lt;? extends E&gt;、List&lt;? super E&gt; 擦除后的类型为 List;</li>
<li>List&lt;T extends Serialzable &amp; Cloneable&gt; 擦除后类型为 List。</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>反射就是Reflection，Java的反射是指程序在<strong>运行期</strong>可以拿到一个对象的所有信息。<br>原理：Java程序的执行分为编译和运行两步，<strong>编译后会生成字节码(.class)文件</strong>，JVM进行类加载的时候，会加载字节码文件，<strong>将类型相关的所有信息加载进方法区</strong>，反射就是去获取这些信息，然后进行操作，</p>
<h2 id="集合-List-Map-Set"><a href="#集合-List-Map-Set" class="headerlink" title="集合(List, Map, Set)"></a>集合(List, Map, Set)</h2><h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>ArrayList是基于数组的集合，在定义时大小是确定的，当容量超过数组长度就会触发扩容。<br>ArrayList的扩容是<strong>创建一个1.5倍的新数组</strong>，然后把原数组的值拷贝过去。</p>
<h3 id="ArrayList如何序列化？为什么要用transient修饰数组？"><a href="#ArrayList如何序列化？为什么要用transient修饰数组？" class="headerlink" title="ArrayList如何序列化？为什么要用transient修饰数组？"></a>ArrayList如何序列化？为什么要用transient修饰数组？</h3><p>ArrayList的序列化是通过<strong>readObject</strong>、<strong>writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<strong>ObjectOutputStream</strong>和<strong>ObjectInputStream</strong>来进行序列化和反序列化。</p>
<img src="/2023/06/03/java-basic-interview-questions/ArrayList-readObject-writeObject.png" class="">

<p>元素数组elementData使用<strong>transient</strong>修饰，这样序列化的时候不会直接序列化元素数组，这是出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50可以不用序列化，所以通过自定义的<strong>readObject</strong>、<strong>writeObject</strong>提高了序列化和反序列化的效率，同时节省内存空间</p>
<img src="/2023/06/03/java-basic-interview-questions/arraylist-transient-elementData.png" class="">

<h3 id="CopyOnWriteArrayList原理"><a href="#CopyOnWriteArrayList原理" class="headerlink" title="CopyOnWriteArrayList原理"></a>CopyOnWriteArrayList原理</h3><p>线程安全版本的ArrayList<br>原理：CopyOnWriteArrayList主要采用<strong>读写分离</strong>的并发策略，允许<strong>并发读</strong>，<strong>读操作时无锁的</strong>，性能较高。写操作时，首先<strong>将当前容器复制一份</strong>，然后在<strong>新副本</strong>上执行写操作(加锁写)，完成后<strong>将原容器的引用指向新容器</strong>。</p>
<img src="/2023/06/03/java-basic-interview-questions/CopyOnWriteArrayList.png" class="">


<h3 id="说一说HashMap的数据结构"><a href="#说一说HashMap的数据结构" class="headerlink" title="说一说HashMap的数据结构"></a>说一说HashMap的数据结构</h3><ul>
<li><p>JDK1.7的数据结构是<strong>数组+链表</strong></p>
</li>
<li><p>JDK1.8的数据结构是<strong>数组+链表+红黑树</strong><br>数据结构图：</p>
<img src="/2023/06/03/java-basic-interview-questions/hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="">
</li>
<li><p>桶数组用于存放元素</p>
</li>
<li><p>链表用于解决冲突</p>
</li>
<li><p>红黑树用于提高查询效率</p>
</li>
</ul>
<h3 id="说一说HashMap的put的流程"><a href="#说一说HashMap的put的流程" class="headerlink" title="说一说HashMap的put的流程"></a>说一说HashMap的put的流程</h3><img src="/2023/06/03/java-basic-interview-questions/hashMap%E7%9A%84put%E6%B5%81%E7%A8%8B.png" class="">

<pre><code class="java">/**
     * Implements Map.put and related methods.
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don&#39;t change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123; // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
</code></pre>
<ol>
<li>首先进行哈希值的扰动，取得一个新的哈希值。</li>
</ol>
<pre><code class="java">static final int hash(Object key) &#123;
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
</code></pre>
<ol start="2">
<li>判断tab是否为空或者长度为0，如果是则进行扩容</li>
</ol>
<pre><code class="java">if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
</code></pre>
<ol start="3">
<li>根据哈希值计算下标</li>
<li>如果tab[i &#x3D; (n - 1) &amp; hash]为空，则直接存放数据</li>
<li>如果tab[i &#x3D; (n - 1) &amp; hash]不为空，则判断key是否相同，相同则直接覆盖</li>
<li>如果key不相同，判断tab[i &#x3D; (n - 1) &amp; hash]是否是树节点，如果是则向树中插入节点</li>
<li>如果tab[i &#x3D; (n - 1) &amp; hash]不是树节点，则将节点插入链表。</li>
<li>如果找到链表中相同key的节点，则覆盖节点</li>
<li>未找到链表中相同key的节点，则将节点插入到链表的尾节点，判断链表长度是否大于8，是则将链表转为红黑树。</li>
<li>最后判断是否超过阈值（threshold），超过则扩容</li>
</ol>
<h3 id="说一说HashMap怎么查找元素"><a href="#说一说HashMap怎么查找元素" class="headerlink" title="说一说HashMap怎么查找元素"></a>说一说HashMap怎么查找元素</h3><img src="/2023/06/03/java-basic-interview-questions/HashMap%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0.png" class="">
<pre><code class="java">/**
 * Returns the value to which the specified key is mapped,
 * or &#123;@code null&#125; if this map contains no mapping for the key.
 *
 * &lt;p&gt;More formally, if this map contains a mapping from a key
 * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null :
 * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise
 * it returns &#123;@code null&#125;.  (There can be at most one such mapping.)
 *
 * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;
 * indicate that the map contains no mapping for the key; it&#39;s also
 * possible that the map explicitly maps the key to &#123;@code null&#125;.
 * The &#123;@link #containsKey containsKey&#125; operation may be used to
 * distinguish these two cases.
 *
 * @see #put(Object, Object)
 */
public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

/**
 * Implements Map.get and related methods.
 *
 * @param hash hash for key
 * @param key the key
 * @return the node, or null if none
 */
final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) &#123;
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do &#123;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<ul>
<li>使用扰动函数，获取哈希值</li>
<li>计算数组下标，获取节点</li>
<li>当前节点和key匹配，直接返回</li>
<li>否则，判断当前节点是否为树节点，是则查找红黑树，</li>
<li>否则，遍历链表</li>
</ul>
<h3 id="HashMap的哈希扰动函数是如何设计的？"><a href="#HashMap的哈希扰动函数是如何设计的？" class="headerlink" title="HashMap的哈希扰动函数是如何设计的？"></a>HashMap的哈希扰动函数是如何设计的？</h3><p>HashMap的哈希函数先拿到key的hashCode，是一个<strong>32位</strong>的int类型的数组，然后让<strong>hashCode的高16位和低16位进行异或操作</strong>，这样设计<strong>降低了哈希碰撞的概率</strong></p>
<pre><code class="java">static final int hash(Object key) &#123;
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
</code></pre>
<h3 id="为什么哈希-x2F-扰动函数能降低hash碰撞"><a href="#为什么哈希-x2F-扰动函数能降低hash碰撞" class="headerlink" title="为什么哈希&#x2F;扰动函数能降低hash碰撞"></a>为什么哈希&#x2F;扰动函数能降低hash碰撞</h3><p>因为HashMap中的模运算是把散列值和（数组长度-1）做“与&amp;”位运算，位运算比取余%运算快。HashMap的数组长度是<strong>2的整数幂</strong>，做与运算相当于将高位置0，只保留低位，这样只取低位容易产生碰撞，扰动函数混合了哈希码的高位和低位，加大了低位的随机性。（ps:TODO，画下图，不然转头又忘了。。。）</p>
<img src="/2023/06/03/java-basic-interview-questions/hashMap-%E6%A8%A1%E8%BF%90%E7%AE%97.png" class="">

<h3 id="为什么HashMap的容量是2的倍数呢？"><a href="#为什么HashMap的容量是2的倍数呢？" class="headerlink" title="为什么HashMap的容量是2的倍数呢？"></a>为什么HashMap的容量是2的倍数呢？</h3><ul>
<li>第一，方便<strong>哈希取余</strong>，hash%数组大小 &#x3D;&#x3D; hash&amp;(数组大小-1) ，位运算的效率更高</li>
<li>第二，在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素转移到新的table中<br>（ps：感觉答的一般，后面补。。。）</li>
</ul>
<h3 id="HashMap扩容机制是怎么样的？"><a href="#HashMap扩容机制是怎么样的？" class="headerlink" title="HashMap扩容机制是怎么样的？"></a>HashMap扩容机制是怎么样的？</h3><ul>
<li>1.8之前是重新计算每个元素的哈希值</li>
<li>1.8之后，<strong>HashMap的初始容量是2的次幂</strong>，扩容后的长度是原来的两倍，则新的容量也是2的次幂，所以<strong>元素要么在原位置，要么在原位置再移动2的次幂</strong><br>(ps：todo，画图理解下，等下又忘了)</li>
</ul>
<h3 id="jdk1-8HashMap主要做了哪些优化？"><a href="#jdk1-8HashMap主要做了哪些优化？" class="headerlink" title="jdk1.8HashMap主要做了哪些优化？"></a>jdk1.8HashMap主要做了哪些优化？</h3><ul>
<li><p>数据结构<br>  数组+链表改成了数据+链表+红黑树<br>  原因：发生hash冲突时，元素会存入链表，联表太长的就转为红黑树，将<strong>时间复杂度从O(n)降为O(logn)</strong></p>
</li>
<li><p>链表插入方式<br>  头插法改成尾插法<br>  原因：1.7时头插法扩容时，会使链表发生反转，<strong>多线程环境下会产生环</strong></p>
</li>
<li><p>扩容resah<br>  1.7扩容时，需要对原数组中的元素进行重新hash定位在新数组的位置<br>  1.8扩容时，不重新计算，利用数组容量是2的次幂，扩容后也是2的次幂，新的位置不变或索引+旧的数组容量大小<br>  原因：提高扩容的效率，更快地扩容</p>
</li>
<li><p>扩容机制<br>  在插入时，1.7判断是否需要扩容再插入，1.8先进行插入，插入完成时再判断是否需要扩容</p>
</li>
<li><p>散列函数<br>  1.7做了四次移位和四次异或，jdk1.8只做一次<br>  原因：做4次的话，边际效用不大，改为一次，提升效率。</p>
</li>
</ul>
<h3 id="你能自己设计实现一个HashMap吗？（TODO，写代码）"><a href="#你能自己设计实现一个HashMap吗？（TODO，写代码）" class="headerlink" title="你能自己设计实现一个HashMap吗？（TODO，写代码）"></a>你能自己设计实现一个HashMap吗？（TODO，写代码）</h3><p>整体设计</p>
<ul>
<li>散列函数：hashCode + 除数留余法</li>
<li>冲突解决：链地址法</li>
<li>扩容：节点重新hash获取位置</li>
</ul>
<p>代码TODO</p>
<h3 id="HashMap是线程安全的吗？多线程下会有什么问题？"><a href="#HashMap是线程安全的吗？多线程下会有什么问题？" class="headerlink" title="HashMap是线程安全的吗？多线程下会有什么问题？"></a>HashMap是线程安全的吗？多线程下会有什么问题？</h3><p>HashMap是非线程安全的，在多线程下可能会出现以下问题</p>
<ul>
<li>多线程下扩容死循环。1.7中hashMap使用<strong>头插法</strong>插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。1.8采用<strong>尾插法</strong>插入元素，<strong>在扩容时保持链表元素原本的顺序</strong>，不会出现环形链表的问题。</li>
<li>多线程下put并发时，如果计算出来的位置相同，则前一key会被后一个key覆盖，从而导致元素丢失。</li>
<li>put和get并发时，可能导致get为null.线程1执行put时，元素个数超过threshold而导致rehash，线程2次时执行get，可能导致这个问题。</li>
</ul>
<h3 id="讲讲ConcurrentHashMap的具体实现？"><a href="#讲讲ConcurrentHashMap的具体实现？" class="headerlink" title="讲讲ConcurrentHashMap的具体实现？"></a>讲讲ConcurrentHashMap的具体实现？</h3><ul>
<li>1.7是使用<strong>分段锁</strong>的机制<br>ConcurrentHashMap里包含一个Segment数组，<strong>Segment数组继承自ReentrantLock</strong>，Segment数组包含HashEntry的数组，HashEntry是个链表结构，具有保存key、value的能力，并有指向下一个节点的指针。<br>其实相当于每个Segmment都是一个HashMap，默认长度为16，则支持16个线程的并发写，segment之间互不影响。</li>
</ul>
<p>put流程：<br>    1. 计算hash，定位到是哪一个segment，如果为空则初始化<br>    2. 使用ReentrantLock加锁，如果失败则自旋，自旋超过次数就阻塞获取，保证一定获取锁成功。<br>    3. 遍历HashEntry，key和hash一样就替换，否则插入链表（流程跟HashMap一样）</p>
<p>get流程：<br>    key通过hash定位到segment，再遍历链表定位到具体的元素上，因value是volatile，所以无需加锁</p>
<img src="/2023/06/03/java-basic-interview-questions/ConcurrentHashMap1.7-%E7%BB%93%E6%9E%84.png" class="">

<ul>
<li>1.8 CAS + synchronized<br>1.8实现线程安全没有采用分段锁，它的数据结构和HashMap是一样的，数组+链表+红黑树，它实现线程安全的关键点在于put流程。<br>put流程：<img src="/2023/06/03/java-basic-interview-questions/ConCurrentHashMap-put%E6%B5%81%E7%A8%8B(1.8).png" class=""></li>
</ul>
<pre><code class="java">    /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode()); // 1.计算Hash
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) &#123; // 2.开始遍历数组
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0) // 3.数组为空，则进行初始化
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 4.tab[i]为空，则自旋写入
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            &#125;
            else if ((fh = f.hash) == MOVED) // 5.判断是否需要扩容
                tab = helpTransfer(tab, f);
            else &#123;
                V oldVal = null;
                synchronized (f) &#123; // 6. 加锁 
                    if (tabAt(tab, i) == f) &#123; // 7.hash碰撞
                        if (fh &gt;= 0) &#123; // 8.是否是链表
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) &#123;
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                &#125;
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) &#123;
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                &#125;
                            &#125;
                        &#125;
                        else if (f instanceof TreeBin) &#123; // 9.是否是红黑树
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) &#123;
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            &#125;
                        &#125;
                    &#125;
                &#125;
                if (binCount != 0) &#123;
                    if (binCount &gt;= TREEIFY_THRESHOLD) //10.长度超过 TREEIFY_THRESHOLD，则链表转红黑树
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                &#125;
            &#125;
        &#125;
        addCount(1L, binCount);
        return null;
    &#125;
</code></pre>
<p>get流程：<br>跟HashMap基本相同</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><ul>
<li>Thread类有一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap</li>
<li>ThreadLocalMap内部维护着<strong>Entry数组</strong>，每个Entry代表一个完整的对象，<strong>key是ThreadLocal的弱引用</strong>，<strong>value是ThreadLocal的泛型值</strong></li>
<li>每个线程在往ThreadLocal里设置值的时候，都是在往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的Map里找对应的key，从而实现了线程的隔离</li>
<li><strong>ThreadLocal本身不存储值</strong>，它只是作为一个key来让线程往ThreadLocalMap里存取值</li>
</ul>
<h3 id="ThreadLocal内存泄露的原因"><a href="#ThreadLocal内存泄露的原因" class="headerlink" title="ThreadLocal内存泄露的原因"></a>ThreadLocal内存泄露的原因</h3><img src="/2023/06/03/java-basic-interview-questions/ThreadLocal%E5%86%85%E5%AD%98.png" class="">
<p>如图，ThreadLocalMap中的key是ThreadLocal的<strong>弱引用</strong>，弱引用在垃圾回收机制运行的时候就会被回收，若ThreadLocal(则ThreadLocalMap中的key)被垃圾回收器回收了，但因为ThreadLoalMap和Thread的生命周期一致，如果此时它不被回收，则会出现：<strong>ThreadLocalMap的key没了，但是value还在，这就会造成内存泄漏</strong>。</p>
<ul>
<li>解决方法：及时调用remove方法释放内存空间</li>
<li>那为什么key还要设计成弱引用？如果key被设计成强引用，当ThreadLocal Reference被销毁，此时它指向ThreadLocal的强引用就没有了，此时key还强引用指向ThreadLocal，就会导致ThreadLocal不能被回收，就会发生内存泄漏。</li>
</ul>
<h3 id="ThreadLocalMap的结构是怎么样的？"><a href="#ThreadLocalMap的结构是怎么样的？" class="headerlink" title="ThreadLocalMap的结构是怎么样的？"></a>ThreadLocalMap的结构是怎么样的？</h3><ul>
<li>ThreadLocalMap没有实现Map接口</li>
<li>主要两个要素，元素数组和散列方法</li>
<li>元素数组：一个table数组，存储Entry类型的元素，Entry是ThreadLocal弱引用作为key，Object作为value的结构</li>
</ul>
<pre><code class="java">   /**
    * The table, resized as necessary.
    * table.length MUST always be a power of two.
    */
   private Entry[] table;


    /**
    * The entries in this hash map extend WeakReference, using
    * its main ref field as the key (which is always a
    * ThreadLocal object).  Note that null keys (i.e. entry.get()
    * == null) mean that the key is no longer referenced, so the
    * entry can be expunged from table.  Such entries are referred to
    * as &quot;stale entries&quot; in the code that follows.
    */
   static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;
       /** The value associated with this ThreadLocal. */
       Object value;

       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
           super(k);
           value = v;
       &#125;
   &#125;
</code></pre>
<ul>
<li>散列方法：哈希取余法</li>
</ul>
<pre><code class="java"> /**
  * 这里的threadLocalHashCode，每创建一个ThreadLocal对象，它就会新增0x61c88647，
  * 这个数是斐波那契数，也叫黄金分割数。hash增量为这个数字，带来的好处就是hash分布非常均匀
  */
 int i = key.threadLocalHashCode &amp; (len-1);
</code></pre>
<h3 id="ThreadLocalMap怎么解决Hash冲突的？"><a href="#ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="ThreadLocalMap怎么解决Hash冲突的？"></a>ThreadLocalMap怎么解决Hash冲突的？</h3><p>开放定址法</p>
<h3 id="说说对JAVA内存模型-JMM-的理解"><a href="#说说对JAVA内存模型-JMM-的理解" class="headerlink" title="说说对JAVA内存模型(JMM)的理解"></a>说说对JAVA内存模型(JMM)的理解</h3><ul>
<li>JMM是一种<strong>抽象的模型</strong>，被定义来屏蔽各种硬件和操作系统的内存访问差异</li>
<li>JMM定义了<strong>线程和主内存之间的抽象关系</strong>：线程之间的共享变量存储在<strong>主内存</strong>中，每个线程都有一个<strong>私有的本地内存</strong>，本地内存中存储了该线程用以读&#x2F;写的<strong>共享变量的副本</strong>。</li>
<li>本地内存是JMM的一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<img src="/2023/06/03/java-basic-interview-questions/JMM.png" class=""></li>
</ul>
<h3 id="volatile实现原理是什么"><a href="#volatile实现原理是什么" class="headerlink" title="volatile实现原理是什么"></a>volatile实现原理是什么</h3><ol>
<li>一个变量被声明为volitile时，线程在写入变量时会把值刷新回主内存，当其他内存读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。这保证了<strong>可见性</strong>。</li>
<li>volatile会限制编译器重排序和处理器重排序，保证<strong>有序性</strong>。</li>
</ol>
<h3 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h3><ul>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ul>
<h3 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h3><p>ps: 反编译javap -c -s -v -l Demo.class，查看字节码指令</p>
<pre><code class="java">public class Demo &#123;

    public static Object obj = new Object();

    public static void main(String[] args) &#123;
        Demo.test();
        Demo.test2();
    &#125;

    public static void test2() &#123;
        synchronized (obj) &#123;
            System.out.println(&quot;hello world2&quot;);
        &#125;
    &#125;

    public synchronized static void test() &#123;
        System.out.println(&quot;hello world&quot;);
    &#125;

&#125;
</code></pre>
<ol>
<li><p>synchronized修饰<strong>代码块</strong>时，JVM采用monitorenter，monitorexit两个指令来实现同步，monitorenter指令指向<strong>同步代码块的开始位置</strong>，monitorexit指令则指向<strong>同步代码块的结束位置</strong>。</p>
<img src="/2023/06/03/java-basic-interview-questions/synchronized%E4%BB%A3%E7%A0%81%E5%9D%97.png" class="">
</li>
<li><p>synchronized修饰<strong>同步方法</strong>时，JVM采用<strong>ACC_SYNCHRONIZED</strong>标记符来实现同步，这个标识指明了该方法是一个同步方法。</p>
<img src="/2023/06/03/java-basic-interview-questions/synchronized%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95.png" class=""></li>
</ol>
<h3 id="synchronized如何实现可见性、有序性、可重入性"><a href="#synchronized如何实现可见性、有序性、可重入性" class="headerlink" title="synchronized如何实现可见性、有序性、可重入性"></a>synchronized如何实现可见性、有序性、可重入性</h3><ul>
<li>可见性<ul>
<li>线程<strong>加锁前</strong>，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值</li>
<li>线程<strong>加锁后</strong>，其他线程无法获取主内存中的共享变量</li>
<li>线程<strong>解锁前</strong>，必须把共享变量的最新值刷新到主内存中</li>
</ul>
</li>
<li>有序性<ul>
<li>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是<strong>单线程</strong>执行的</li>
<li>因为as-if-serial语义的存在，单线程的程序保证最终结果是有序的，但是不保证指令重排。</li>
</ul>
</li>
<li>可重入性<ul>
<li>synchronized锁对象有个计数器，会记录线程获取锁的次数，执行完对应代码块之后，计数器就会-1，直到计数器清零，就释放锁</li>
</ul>
</li>
</ul>
<h3 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h3><p>（简单总结，后面细化下）<br>AbstractQueuedSynchronizer，抽象同步队列，简称AQS，它是java并发包的根基，并发包中的锁就是基于AQS实现的</p>
<ul>
<li><p>AQS是基于一个<strong>FIFO的双向队列</strong>，其内部定义了一个节点类Node，Node节点内部的<strong>SHARED</strong>用来标记该线程是获取<strong>共享资源</strong>时被阻挂起后放入AQS队列的，<strong>EXCLUSIVE</strong>用来标记线程是否是取<strong>独占资源</strong>时被挂起后放入AQS队列</p>
</li>
<li><p>AQS使用一个<strong>volatile修饰的int类型的成员变量state</strong>来表示同步状态，修改同步状态成功即为获取锁，volatile保证了变量在多线程之间的可见性，修改state值时通过<strong>CAS机制</strong>来保证修改的原子性</p>
</li>
<li><p>获取state的方式，分为<strong>独占</strong>和<strong>共享</strong>，一个线程使用独占方式获取了资源，其他线程获取失败被阻塞。一个线程使用共享方式获取了资源，另一个线程还可以通过CAS的方式进行获取</p>
</li>
<li><p>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS中会将竞争共享资源失败的线程添加到一个<strong>变体的CLH变体</strong>中</p>
</li>
<li><p>CLH：Craig Landin and Hagersten对列，是 单向链表实现的对列。 <strong>申请线程只在本地变量上自旋</strong>，它<strong>不断轮训前驱的状态</strong>，如果发现前驱节点释放了锁就结束自旋。</p>
</li>
<li><p>AQS中的CLH变体队列，是一个<strong>虚拟双向队列</strong>，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配，它拥有一下特性</p>
<ul>
<li>AQS中队列是个双向链表，也是FIFO先进先出的特性</li>
<li>通过Head、Tail头尾连个节点来组成队列的结构，通过volatile修饰保证可见性</li>
<li>Head指向节点为已经获得锁的节点，是一个<strong>虚拟节点</strong>，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对CLH队列性能较好</li>
</ul>
<h3 id="CAS是什么？有什么问题？如何解决"><a href="#CAS是什么？有什么问题？如何解决" class="headerlink" title="CAS是什么？有什么问题？如何解决"></a>CAS是什么？有什么问题？如何解决</h3><p>  CAS也叫做CompareAndSwap，比较并交换，主要通过<strong>处理器指令</strong>来保证操作的原子性.<br>  CAS指令包含三个参数：共享变量的内存地址A、预期的值B和共享变量的新值，只有当内存地址A处的值等于B时，才能将内存中地址A处的值更新为新值<br>  CAS问题：</p>
<ol>
<li>ABA：并发环境下，假设初始条件是A，去修改数据，判断是A就会执行修改，但是其实中间发生了<strong>A改成B又改回A</strong>的情况，这样即使成功修改，还是可能有问题<br>  解决方法: <strong>加版本号</strong>，每次修改变量就在变量的版本号上加1，这样发生ABA的情况时，也可以从版本号上判断已经修改过了。</li>
<li>循环性能开销：自旋CAS如果一直执行，一直不成功，会给CPU带来很大的开销<br>  解决方法：设置一个<strong>自旋次数</strong>的限制，超过一定次数就停止自旋</li>
<li>只能保证一个变量的原子操作：CAS只能保证一个变量的原子操作，无法保证多个变量操作时的原子性<br>  解决方法：1.<strong>加锁</strong>  2.考虑<strong>合并多个变量</strong>，如把多个变量封装成一个对象，通过AtomicReference来保证原子性</li>
</ol>
</li>
</ul>
<h3 id="线程池有哪些参数"><a href="#线程池有哪些参数" class="headerlink" title="线程池有哪些参数"></a>线程池有哪些参数</h3><ol>
<li>corePoolSize：核心线程数<br> 用来初始化线程池中<strong>核心线程数</strong>，当线程池中线程数小于corePoolSize时，系统默认添加一个任务才创建一个线程。当线程数 &#x3D;&#x3D; corePoolSize时，新任务会放到 workQueue</li>
<li>maximumPoolSize：最大线程数<br> 表示允许的最大线程&#x3D;（非核心线程数+核心线程数），当workQueue也满了，但是线程池中的总线程数小于maximumPoolSize时，会再次创建新线程</li>
<li>keepAliveTime：非核心线程存活时间</li>
<li>unit：非核心线程存活时间单位</li>
<li>workQueue：等待对列<br> 当运行线程数&#x3D;&#x3D;corePoolSize时，新的任务会被添加到workQueue，当当orkQueue也满了，但是线程池中的总线程数小于maximumPoolSize时，会再次创建新线程</li>
<li>threadFactory：创建线程使用工厂<br> 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等</li>
<li>handler：饱和拒绝策略<br> corePoolSize、workQueue、maximumPoolSize都不可用的时候执行的饱和策略</li>
</ol>
<h3 id="线程池的拒绝策略有哪些"><a href="#线程池的拒绝策略有哪些" class="headerlink" title="线程池的拒绝策略有哪些"></a>线程池的拒绝策略有哪些</h3><ol>
<li>AbortPolicy：默认策略，直接抛出异常</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务</li>
<li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务</li>
<li>DiscardPolicy：当前任务直接丢弃</li>
</ol>
<h3 id="线程池提交execute和submit有哪些区别？"><a href="#线程池提交execute和submit有哪些区别？" class="headerlink" title="线程池提交execute和submit有哪些区别？"></a>线程池提交execute和submit有哪些区别？</h3><ol>
<li>execute用于提交不需要返回值的任务</li>
<li>submit用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li>
</ol>
<h3 id="常见的线程池有哪些"><a href="#常见的线程池有哪些" class="headerlink" title="常见的线程池有哪些"></a>常见的线程池有哪些</h3><ol>
<li>newFixedThreadPool: 固定数目线程的线程池</li>
<li>newCachedThreadPool: 可缓存线程的线程池</li>
<li>newSingleThreadExecutor: 单线程的线程池</li>
<li>newScheduledThreadPool: 定时及周期执行的线程池</li>
</ol>
<h3 id="线程池异常怎么处理"><a href="#线程池异常怎么处理" class="headerlink" title="线程池异常怎么处理"></a>线程池异常怎么处理</h3><ol>
<li>try-catch捕获异常</li>
<li>submit执行，Future.get接受异常</li>
<li>重写 ThreadPoolExecutor.afterExecute方法，处理传递的异常引用</li>
<li>实例化时，传入自己的ThreadFactory，设置Thread.UncaughtExceptionHandler处理未检测的异常</li>
</ol>
<h3 id="线程池有几种状态"><a href="#线程池有几种状态" class="headerlink" title="线程池有几种状态"></a>线程池有几种状态</h3><img src="/2023/06/03/java-basic-interview-questions/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" class="">
<p>RUNNING:</p>
<ol>
<li>接受新任务，并处理阻塞队列中的任务</li>
</ol>
<p>SHUTDOWN:</p>
<ol>
<li>不会接受新任务，但<strong>会处理阻塞队列中的任务</strong></li>
<li>队列为空，且线程池中执行的任务也为空，进入TIDYING状态</li>
</ol>
<p>STOP:</p>
<ol>
<li><strong>该状态不会接受新任务，也不会处理阻塞队列中的任务</strong>，同时会中断正在运行的任务</li>
<li>线程池中之行的任务为空，进入TIDYING状态</li>
</ol>
<p>TIDYING</p>
<ol>
<li>该状态表明所有的任务已经运行终止，记录的任务数量为0</li>
<li>terminated()执行完毕，进入TERMINATED状态</li>
</ol>
<p>TERMINATED</p>
<ol>
<li>线程池彻底终止</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="说说JVM的内存区域"><a href="#说说JVM的内存区域" class="headerlink" title="说说JVM的内存区域"></a>说说JVM的内存区域</h3><p>JVM内存区域的粗略划分为<strong>堆</strong>和<strong>栈</strong>，按虚拟机规范，可划分为如下的区域：</p>
<img src="/2023/06/03/java-basic-interview-questions/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" class="">
<ol>
<li><p>程序计数器</p>
<ul>
<li>它也被称为PC寄存器，可以看作是<strong>当前线程</strong>所执行的字节码的<strong>行号指示器</strong>，是一块较小的内存空间</li>
</ul>
</li>
<li><p>Java虚拟机栈：</p>
<ul>
<li>它描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态链接等</li>
<li>它的生命周期与线程相同</li>
</ul>
</li>
<li><p>本地方法栈：</p>
<ul>
<li>作用与虚拟机栈的作用相似，区别在于<strong>本地方法栈为虚拟机使用到的本地(Native)方法服务</strong>，而虚拟机栈是执行Java方法服务</li>
<li>Java虚拟机规范允许本地方法栈被实现成固定大小的或者根据计算动态扩展和收缩的</li>
</ul>
</li>
<li><p>Java堆</p>
<ul>
<li>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建</li>
<li>该区域的唯一目的就是存放对象实例，Java里大部分对象实例都在这里分配内存</li>
<li>Java堆是<strong>垃圾收集器管理</strong>的内存区域，所以有时也被称为“GC堆”<ul>
<li>从内存回收的角度，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以常常会把堆分为：新生代、老年代、Eden空间、From Survivor空间、To Survivor空间等，<strong>注意这种划分只是根据垃圾回收机制来进行划分，不是Java虚拟机规范本身制定的</strong>，PS: Eden:From Survivor:To Survivor 比例是 8:1:1 <img src="/2023/06/03/java-basic-interview-questions/Java%E5%A0%86-%E4%BB%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%A7%92%E5%BA%A6%E5%88%92%E5%88%86.png" class=""></li>
</ul>
</li>
</ul>
</li>
<li><p>方法区：</p>
<ul>
<li>用于存储已被加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存等数据</li>
<li>Java虚拟机栈规范对其约束很宽松，因此方法区具体实现经历很多改动，在jdk1.7前使用永久代作为方法区的实现</li>
</ul>
</li>
</ol>
<h3 id="说说JDK1-7和JDK1-8内存区域的变化"><a href="#说说JDK1-7和JDK1-8内存区域的变化" class="headerlink" title="说说JDK1.7和JDK1.8内存区域的变化"></a>说说JDK1.7和JDK1.8内存区域的变化</h3><p>主要是方法区的改变，1.7的方法区是在永久代实现的，1.8去掉了永久代改为在直接内存开辟一个元空间代替</p>
<img src="/2023/06/03/java-basic-interview-questions/jdk1.7-jdk1.8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%AF%B9%E6%AF%94.png" class="">

<h3 id="什么是指针碰撞？什么是空闲列表？"><a href="#什么是指针碰撞？什么是空闲列表？" class="headerlink" title="什么是指针碰撞？什么是空闲列表？"></a>什么是指针碰撞？什么是空闲列表？</h3><p>内存分配有两种方式：指针碰撞（Bump The Pointer）和空闲列表（Free List）</p>
<ul>
<li>指针碰撞：假设Java堆中内存是<strong>绝对规整</strong>的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，<strong>中间放着一个指针作为分界点的指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li>
<li>空闲列表：如果<strong>Java堆中的内存并不是规整的</strong>，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li>
<li>两种方式的选择由<strong>Java堆是否规整</strong>决定，Java堆是否规整是由选择的<strong>垃圾收集器</strong>是否具有压缩整理能力决定的<img src="/2023/06/03/java-basic-interview-questions/%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8.png" class=""></li>
</ul>
<h3 id="JVM里new对象时，堆是否会发生抢占？JVM是怎么来保证线程安全的？"><a href="#JVM里new对象时，堆是否会发生抢占？JVM是怎么来保证线程安全的？" class="headerlink" title="JVM里new对象时，堆是否会发生抢占？JVM是怎么来保证线程安全的？"></a>JVM里new对象时，堆是否会发生抢占？JVM是怎么来保证线程安全的？</h3><p>会发生抢占，以指针碰撞为例，一个线程正在给A对象分配内存，指针还没修改时，另一个线程又为B分配内存，这就发生了抢占。<br>解决方法有两种</p>
<ol>
<li>采用<strong>CAS分配重试</strong>的方式来保证更新操作的原子性</li>
<li>每个线程在Java堆中预先分配一小块内存，即<strong>本地线程分配缓冲</strong>(Thread Local Allocation Buffer, TLAB)，要分配内存的线程，先在本地缓冲区分配，只有本地缓冲区用完了，分配新的内存时才需要同步锁定<img src="/2023/06/03/java-basic-interview-questions/%E5%A0%86%E6%8A%A2%E5%8D%A0.png" class=""></li>
</ol>
<h3 id="导致内存泄漏的原因有哪些？"><a href="#导致内存泄漏的原因有哪些？" class="headerlink" title="导致内存泄漏的原因有哪些？"></a>导致内存泄漏的原因有哪些？</h3><ol>
<li>静态集合类<br> <strong>静态集合的生命周期和JVM一致</strong>，所以静态集合引用的对象不能被释放</li>
</ol>
<pre><code class="java">public class Test &#123;
    static List list = new ArrayList();
    
    public void test() &#123;
        Object obj = new Object();
        list.add(obj);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>单例模式<br> 单例对象在初始化后以静态变量的方式在JVM的生命周期中存在，如果单例对象持有外部引用，那这个外部的对象将不会被GC回收</li>
<li>连接(IO&#x2F;数据)未释放<br> 数据链接、IO、Socket等连接，创建后不再使用时，需要调用close方法光笔，只有关闭后，GC才会回收对象。</li>
<li>变量作用域过大<br> 一个变量的定义作用域大于其使用范围，很可能存在内存泄漏，或不再使用对象没有及时将对象设置为null，也可能造成内存泄漏</li>
</ol>
<pre><code class="java">public class Test &#123;
    Object object;
    public void test() &#123;
       object = new Object();
       // 一顿操作.....
       // 由于作用域原因，test执行完成后，object对象分配的内存不会马上释放
       // object = null;
    &#125;
&#125;
</code></pre>
<ol start="5">
<li>hash值发生变化<br> 对象Hash值改变，使用HashMap、HashSet等容器时，由于对象修改后Hash值和存储进容器值时的Hash值不用，所以无法找到存入的对象，因此无法删除对象，从而造成内存泄漏。</li>
<li>ThreadLocal使用不当<br> ThreadLocal的弱引用会造成内存泄漏的问题，使用完记得调用remove方法</li>
</ol>
<h3 id="如何判断对象仍然存活？"><a href="#如何判断对象仍然存活？" class="headerlink" title="如何判断对象仍然存活？"></a>如何判断对象仍然存活？</h3><p>两种方式：引用计数算法和可达性分析算法</p>
<ol>
<li>引用计数算法<br> 在对象中添加一个引用计数器，每当有一个地方引用时，计数器值就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象就是不可能再被使用的</li>
<li>可达性分析算法<br> Java虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于<strong>将一系列GC Roots作为初始的存活对象合集（GC Root Set）</strong>,然后从该合集出发，探索所有可以被该集合引用到的对象，并将其加入到该集合中，该过程也称为<strong>标记</strong>。最终，未被探索到的对象便是死亡的，可以回收的 <img src="/2023/06/03/java-basic-interview-questions/%E5%8F%AF%E8%BE%BE%E6%80%A7.png" class="">
 GC Roots的主要对象有四种<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中<strong>类静态属性</strong>引用的对象</li>
<li>方法区<strong>常量</strong>引用的对象</li>
<li><strong>本地方法栈</strong>中JNI引用的对象</li>
</ul>
</li>
</ol>
<h3 id="常用垃圾收集算法是什么？"><a href="#常用垃圾收集算法是什么？" class="headerlink" title="常用垃圾收集算法是什么？"></a>常用垃圾收集算法是什么？</h3><ol>
<li>标记-清除</li>
<li>标记-复制</li>
<li>标记-整理<br>细节补充…</li>
</ol>
<h3 id="说一说新生代区域"><a href="#说一说新生代区域" class="headerlink" title="说一说新生代区域"></a>说一说新生代区域</h3><p>新生代的垃圾收集主要采用<strong>标记-复制</strong>算法，因为新生代的存活对象比较少，<strong>每次复制少量的存活对象效率比较高</strong>。<br>基于这种算法，虚拟机将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor空间上，然后直接清除掉Eden和已经用过的Survivor的空间。默认比列为8:1:1</p>
<img src="/2023/06/03/java-basic-interview-questions/%E6%96%B0%E7%94%9F%E4%BB%A3.png" class="">

<h3 id="Full-GC什么时候触发？"><a href="#Full-GC什么时候触发？" class="headerlink" title="Full GC什么时候触发？"></a>Full GC什么时候触发？</h3><ol>
<li>Young GC之前检查老年代<br> 在要进行Young GC的时候，发现 <strong>老年代可用的连续空间 &lt; 新生代历次Young GC后升入老年代的对象总和的平均大小</strong>，说明本次Young GC后可能升入老年代的对象大小 可能超过了 老年代当前可用的空间，那就会触发Full GC</li>
<li>Young GC之后老年代空间不足<br> 执行Young GC后，有一批对象需要放入到老年代，但老年代空间不足，触发Full GC</li>
<li>老年代空间不足<br> 老年代内存使用率过高，达到一定比例，也会触发Full GC</li>
<li>空间分配担保失败<br> 新生代的To区放不下从Eden和From拷贝过来对象，或者新生代对象GC年龄到达阈值需要晋升，老年代如果放不下的话就会触发Full GC</li>
<li>方法区内存空间不足<br> 如果方法区由永久代实现，永久代空间不足Full GC</li>
<li>System.gc()等命令触发<br> System.gc()、jmap -dump等命令会触发Full GC</li>
</ol>
<h3 id="对象什么时候进入老年代？"><a href="#对象什么时候进入老年代？" class="headerlink" title="对象什么时候进入老年代？"></a>对象什么时候进入老年代？</h3><ol>
<li><p>长期存活的对象进入老年代<br> 在对象的<strong>对象头</strong>信息中存储着对象的<strong>迭代年龄</strong>会在Young GC之后对象的移区操作中增加，每次移区年龄加一，当年龄达到（15）之后，这个对象将会移入老年代<br> 可通过-XX:MaxTenuringThreshold 设置</p>
</li>
<li><p>大对象直接进入老年代<br> 一些<strong>占用大量连续内存空间的对象</strong>在被加载时就会进入老年代，一般都是一些数组、长字符串之类的<br> 可通过-XX：PretenureSizeThreshold设置</p>
</li>
<li><p>动态对象年龄判定<br> 为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong></p>
</li>
<li><p>空间分配担保<br> 在Young GC之后，新生代仍然有很多对象存活，就需要老年代进行<strong>分配担保</strong>，把Survivor无法容纳的对象直接送入老年代</p>
</li>
</ol>
<h3 id="常用的垃圾收集器有哪些？"><a href="#常用的垃圾收集器有哪些？" class="headerlink" title="常用的垃圾收集器有哪些？"></a>常用的垃圾收集器有哪些？</h3><ol>
<li>Serial收集器<br> 最基础、历史最悠久的收集器<br> 它是一个<strong>单线程</strong>工作的收集器，使用<strong>一个处理器</strong>或<strong>一条收集线程</strong>去完成垃圾收集工作。在进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束，则所谓的”Stop The World(STW)”</li>
<li>ParNew<br> Serial的多线程版本，使用多条线程进行垃圾回收，在进行垃圾收集时，也必须暂停其他所有工作线程，直到垃圾收集结束。</li>
<li>Parallel Scavenge<br> 即于标记-复制算法实现，也可以并行收集，主要关注的是垃圾收集的吞吐量，则CPU用于运行用户代码的时间和总消耗时间的比值，比值越大则说明垃圾收集的占比越小</li>
<li>Serial Old<br> Serial的老年代版本，同样是一个单线程收集器，使用标记-整理算法</li>
<li>Parallel Old<br> Parallel Scavenge的老年代版本，支持多线程并发手机，基于标记-整理算法</li>
<li>CMS<br> 一种<strong>以获取最短回收停顿时间为目标</strong>的收集器，同样是老年代的收集器，采用标记-清楚算法</li>
<li>Garbage First(G1)<br> 开创了局部收集的设计思路和基于Region的内存布局形式<img src="/2023/06/03/java-basic-interview-questions/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" class=""></li>
</ol>
<h3 id="说一说CMS垃圾收集器"><a href="#说一说CMS垃圾收集器" class="headerlink" title="说一说CMS垃圾收集器"></a>说一说CMS垃圾收集器</h3><p>CMS收集器的垃圾收集分为四步：</p>
<ol>
<li>初始标记<br> 单线程运行，需要Stop The World，标记GC ROOTs能<strong>直达</strong>的对象</li>
<li>并发标记<br> 无停顿，和用户线程同时运行，从GC ROOTs直达对象开始遍历整个对象图</li>
<li>重新标记<br> 多线程运行，需要Stop The World，标记 并发标记阶段 产生的对象</li>
<li>并发清除<br> 无停顿，和用户线程同时运行，清理掉标记阶段的死亡的对象<img src="/2023/06/03/java-basic-interview-questions/CMS.png" class=""></li>
</ol>
<h3 id="说一说G1垃圾收集器"><a href="#说一说G1垃圾收集器" class="headerlink" title="说一说G1垃圾收集器"></a>说一说G1垃圾收集器</h3><ul>
<li>Garbage First(简称G1)收集器是垃圾收集器的一个颠覆性产物，开创了<strong>局部收集</strong>的设计思路和<strong>基于Region的内存布局</strong>形式。</li>
<li>G1也是遵循分代收集理论设计的，但其堆内存的布局不是按“新生代-老年代-持久代等”划分的。G1把<strong>连续</strong>的Java堆划分为<strong>多个大小相等的独立区域</strong>(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间、或者老年代空间。收集器针对不同的Region采用不同策略去处理，如此就避免了收集整个堆。G1会按照若干个Region集进行收集，同时维护一个优先级列表，跟踪手机各个Region回收的“价值”，优先回收“价值高”的Region<img src="/2023/06/03/java-basic-interview-questions/G1.png" class=""></li>
<li>G1运行的过程可分为四个步骤<ol>
<li>初始标记<br> 标记了从GC Roots开始可直达的对象，STW执行</li>
<li>并发标记<br> 和用护线程同时进行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出要回收的对象</li>
<li>最终标记<br> STW，标记在 并发标记过程中 产生的垃圾</li>
<li>筛选回收<br> STW，制定回收计划，<strong>选择多个Region构成回收集</strong>，把回收集中Region的存活对象复制到空的Region中，在清理整个旧Region的全部空间。</li>
</ol>
</li>
</ul>
<img src="/2023/06/03/java-basic-interview-questions/G1%E6%B5%81%E7%A8%8B.png" class="">

<h3 id="为什么CMS有了，为何还需要引入G1"><a href="#为什么CMS有了，为何还需要引入G1" class="headerlink" title="为什么CMS有了，为何还需要引入G1?"></a>为什么CMS有了，为何还需要引入G1?</h3><p>CMS</p>
<ul>
<li>优点：并发收集、低停顿</li>
<li>缺点：<br>  1. Mark Sweep算法会导致<strong>内存碎片比较多</strong><br>  2. CMS并发能力比较依赖CPU资源，<strong>并发回收时垃圾收集线程可能会抢占用户线程的资源</strong>，导致用户程序性能下降<br>  3. 并发清除阶段，<strong>用户线程依然在运行，会产生“浮动垃圾”</strong>，本次垃圾收集无法处理，必须等到下一次垃圾收集才能处理。如果浮动垃圾过多就会触发新的垃圾回收，导致性能降低</li>
</ul>
<p>G1</p>
<ul>
<li>主要解决了碎片过多的问题。</li>
</ul>
<h3 id="对象一定分配在堆中吗？逃逸分析技术是什么？"><a href="#对象一定分配在堆中吗？逃逸分析技术是什么？" class="headerlink" title="对象一定分配在堆中吗？逃逸分析技术是什么？"></a>对象一定分配在堆中吗？逃逸分析技术是什么？</h3><p>对象不一定分配在堆中。</p>
<ul>
<li>逃逸分析是指<strong>分析指针动态范围</strong>的方法，同编译器优化原理的指针分析和外形分析相关联。</li>
<li>当变量（或者对象）在方法中分配后，<strong>其指针有可能被返回或者被全局引用</strong>，这样就会被其他方法或者线程所引用，这种现象称为<strong>指针（或引用）逃逸</strong>。</li>
<li>当一个对象被new后，它可能被外部所引用，如果作为参数传递到外部了，就称之为<strong>方法逃逸</strong>。</li>
<li>如果对象还可能被外部线程访问到，例如赋值给可以在其他线程中访问的实例变量，这种称为<strong>线程逃逸</strong>。</li>
</ul>
<pre><code class="java">// 未逃逸1
public static void rsStr() &#123;
    User user = new User();
    user.setId(1L);
&#125;

// 未逃逸2
public static String rsStr() &#123;
    User user = new User();
    user.setId(1L);
    return user.toString();
&#125;

// 方法逃逸
public static User rsStr() &#123;
    User user = new User();
    user.setId(1L);
    return user；
&#125;
</code></pre>
<p>逃逸分析的好处</p>
<ol>
<li>栈上分配<br> 如果确定一个对象不会逃逸到线程之外，那就可以考虑<strong>把这个对象分配在栈上</strong>，对象占用的内存随着栈帧出栈而销毁，如此垃圾收集的压力就降低许多</li>
<li>同步消除<br> 线程同步本身是一个相对耗时的过程，如果逃逸分析确定了一个变量不会逃逸出线程，则无法被其他线程访问，那么这个变量的读写就不会有竞争，对这个变量的同步措施就可以安全消除</li>
<li>标量替换<ul>
<li>如果一个数据是基本数据类型，不可拆分，称之为<strong>标量</strong></li>
<li>把一个Java对象拆散，<strong>将其用到的成员变量恢复为原始类型来访问</strong>，这个过程就称为<strong>标量替换</strong></li>
<li>若逃逸分析能够确定一个对象不会被方法外部访问，且这个对象可以被拆散，那么可以不创建对象，<strong>直接用创建若干个成员变量代替</strong>，<strong>可以让对象的成员变量在栈上分配和读写</strong></li>
</ul>
</li>
</ol>
<h3 id="说一说类的生命周期"><a href="#说一说类的生命周期" class="headerlink" title="说一说类的生命周期"></a>说一说类的生命周期</h3><p>类的生命周期需要经历七个阶段：</p>
<p>加载 (Loading)、验证 (Verification)、准备 (Preparation)、解析 (Resolution)、初始化 (Initialization)、使用 (Using)、卸载 (Unloading)</p>
<p>验证、准备、解析这三个部分统称为连接（Linking）</p>
<img src="/2023/06/03/java-basic-interview-questions/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="">

<h3 id="说一说类加载的过程"><a href="#说一说类加载的过程" class="headerlink" title="说一说类加载的过程"></a>说一说类加载的过程</h3><p>加载过程中，JVM主要做三件事</p>
<ol>
<li>通过一个<strong>类的全限定名</strong>来获取定义此类的<strong>二进制字节流</strong></li>
<li>将这个字节流所代表的<strong>静态存储结构</strong>转化为<strong>方法区</strong>的<strong>运行时数据结构</strong></li>
<li>在堆内存中生成一个代表这个类的java.lang.Class对象，<strong>作为方法区这个类的各种数据的访问入口</strong><img src="/2023/06/03/java-basic-interview-questions/%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" class=""></li>
</ol>
<h3 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h3><ul>
<li>启动类加载器（Bootstrap ClassLoader）<br>  用来加载java核心类库，无法被Java程序直接引用</li>
<li>扩展类加载器（extensions class loader）<br>  用来加载Java的扩展库，Java虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载Java类</li>
<li>系统类加载器 (sytem class loader)<br>  它根据Java应用的类路径（CLASSPATH）来加载Java类。一般来说，Java应用的类都是由它完成加载，可以通过ClassLoader.getSystemClassLoader()来获取</li>
<li>用户自定义加载器 (user class loader)<br>  用户通过继承java.lang.ClassLoader类的方式自己实现的类加载器</li>
</ul>
<h3 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h3><img src="/2023/06/03/java-basic-interview-questions/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" class="">
<p>工作过程：如果一个类加载器收到了类加载请求，会把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此最终所有的类加载请求都会传递到最顶层的启动类加载器。<br>只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达. </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
